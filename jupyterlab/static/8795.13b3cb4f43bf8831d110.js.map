{"version":3,"sources":["webpack://@jupyterlab/application-top/./node_modules/leaflet-transform/src/Canvas.js","webpack://@jupyterlab/application-top/./node_modules/leaflet-transform/src/Matrix.js","webpack://@jupyterlab/application-top/./node_modules/leaflet-transform/src/Path.Drag.js","webpack://@jupyterlab/application-top/./node_modules/leaflet-transform/src/Path.Transform.js","webpack://@jupyterlab/application-top/./node_modules/leaflet-transform/src/SVG.VML.js","webpack://@jupyterlab/application-top/./node_modules/leaflet-transform/src/SVG.js","webpack://@jupyterlab/application-top/./node_modules/leaflet-transform/src/Util.js","webpack://@jupyterlab/application-top/./node_modules/leaflet-transform/src/index.js"],"names":["TRUE_FN","L","Canvas","include","_resetTransformPath","layer","this","_containerCopy","_containsPoint_","_containsPoint","_requestRedraw","transformPath","matrix","copy","ctx","_ctx","copyCtx","m","Browser","retina","bounds","_bounds","size","getSize","pos","min","document","createElement","getContext","width","x","height","y","_removePath","_redraw","translate","drawImage","_container","_initPath","save","clearRect","setTransform","restore","transform","apply","_drawing","_updatePath","Matrix","a","b","c","d","e","f","_matrix","prototype","point","_transform","clone","untransform","Point","undefined","translateX","translateY","_add","scale","origin","scaleX","scaleY","rotate","angle","cos","Math","sin","flip","result","src","other","val","i","j","k","Path","_renderer","_update","_onMouseClick","dragging","moved","_map","_fireMouseEvent","END","mousedown","touchstart","pointerdown","MSPointerDown","MOVE","distance","dx","dy","sqrt","Handler","PathDrag","extend","statics","DRAGGING_CLS","initialize","path","_path","_startPoint","_dragStartPoint","_mapDraggingWasEnabled","addHooks","on","_onDragStart","options","className","DomUtil","addClass","removeHooks","off","replace","RegExp","removeClass","_dragMoved","evt","eventType","originalEvent","_simulated","type","containerPoint","DomEvent","stop","_onDrag","_onDragEnd","enabled","disable","_popup","_close","_replaceCoordGetters","first","touches","length","mouseEventToContainerPoint","totalMouseDragDistance","distanceTo","tapTolerance","fire","bringToFront","_transformPoints","_project","_restoreCoordGetters","contains","Util","falseFn","requestAnimFrame","skipped","fakeStop","enable","dest","len","latlng","px","crs","transformation","getZoom","projection","diff","subtract","applyTransform","LatLngBounds","_point","unproject","project","_latlng","_rings","_parts","rings","latlngs","_latlngs","isArray","jj","getLatLng","getLatLng_","bind","getLatLngs","getLatLngs_","makeDraggable","addInitHook","draggable","interactive","module","exports","Drag","PathTransform","Handle","CircleMarker","onAdd","map","call","setCursor","style","cursor","CursorsByType","index","RotateHandle","rotation","scaling","uniformScaling","maxZoom","handlerOptions","radius","fillColor","color","fillOpacity","weight","opacity","boundsOptions","dashArray","fill","noClip","rotateHandleOptions","handleLength","edgesCount","handleClass","rotateHandleClass","_activeMarker","_originMarker","_rotationMarker","_rotationOrigin","_scaleOrigin","_angle","_scale","_initialDist","_initialDistX","_initialDistY","_rotationStart","_rotationOriginPt","_projectedMatrix","_handlersGroup","_rect","_handlers","_handleLine","setOptions","_createHandlers","_hideHandlers","_enabled","merge","rotationOrigin","scaleOrigin","center","getCenter","_updateHandlers","handler","_initialPoint","_applyTransform","_apply","_transformGeometries","layerPointToLatLng","redraw","reset","_rectShape","removeLayer","_getBoundingPolygon","addTo","handlersGroup","toGeoJSON","_origin","_getProjectedMatrix","zoom","getMaxZoom","_transformPoint","projectedMatrix","_reset","LayerGroup","push","_createHandler","_createRotationHandlers","bottom","LatLng","lat","lng","topPoint","handlerPosition","pointOnLine","latLngToLayerPoint","Polyline","RotateHandleClass","_onRotateStart","_getRotationOrigin","lb","rt","layerPoint","_initialMatrix","_onRotate","_onRotateEnd","_cachePoints","previous","atan2","_onScaleStart","marker","target","_onScale","_onScaleEnd","originPoint","ratioX","ratioY","addLayer","eachLayer","GeoJSON","geometryToLayer","Rectangle","getBounds","HandleClass","rect","slice","SVG","vml","_skew","removeChild","skew","create","appendChild","behavior","mt","toFixed","offset","floor","s","l","parseFloat","left","t","top","w","h","isNaN","setAttributeNS","join","start","final","distPx","ratio","key","obj","arguments","isObject","object","Object","toString","hasOwnProperty"],"mappings":";+HAAA,SAASA,IAAa,OAAO,KAE7BC,EAAEC,OAAOC,QAAQ,CAMfC,oBAAqB,SAASC,GAC5B,IAAKC,KAAKC,eAAgB,cAEnBD,KAAKC,eAEZ,GAAIF,EAAMG,gBAAiB,CACzBH,EAAMI,eAAiBJ,EAAMG,uBACtBH,EAAMG,gBAEbF,KAAKI,eAAeL,KAoBxBM,cAAe,SAASN,EAAOO,GAC7B,IAAIC,EAASP,KAAKC,eAClB,IAAIO,EAASR,KAAKS,KAAMC,EACxB,IAAIC,EAAShB,EAAEiB,QAAQC,OAAS,EAAI,EACpC,IAAIC,EAASd,KAAKe,QAClB,IAAIC,EAASF,EAAOG,UACpB,IAAIC,EAASJ,EAAOK,IAEpB,IAAKZ,EAAM,CACTA,EAAOP,KAAKC,eAAiBmB,SAASC,cAAc,UACpDX,EAAUH,EAAKe,WAAW,MAG1Bf,EAAKgB,MAASZ,EAAIK,EAAKQ,EACvBjB,EAAKkB,OAASd,EAAIK,EAAKU,EAEvB1B,KAAK2B,YAAY5B,GACjBC,KAAK4B,UAELlB,EAAQmB,UAAUlB,EAAIG,EAAOK,IAAIK,EAAGb,EAAIG,EAAOK,IAAIO,GACnDhB,EAAQoB,UAAU9B,KAAK+B,WAAY,EAAG,GACtC/B,KAAKgC,UAAUjC,GAGfA,EAAMG,gBAAkBH,EAAMI,eAC9BJ,EAAMI,eAAkBT,EAG1Bc,EAAIyB,OACJzB,EAAI0B,UAAUhB,EAAIM,EAAGN,EAAIQ,EAAGV,EAAKQ,EAAIb,EAAGK,EAAKU,EAAIf,GACjDH,EAAI2B,aAAa,EAAG,EAAG,EAAG,EAAG,EAAG,GAChC3B,EAAI4B,UACJ5B,EAAIyB,OAEJzB,EAAIsB,UAAU9B,KAAKC,eAAgB,EAAG,EAAGe,EAAKQ,EAAGR,EAAKU,GACtDlB,EAAI6B,UAAUC,MAAM9B,EAAKF,GAGzBN,KAAKuC,SAAW,KAChBxC,EAAMyC,cACNxC,KAAKuC,SAAW,MAEhB/B,EAAI4B,c,WCrERzC,EAAE8C,OAAS,SAASC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,GAKjC/C,KAAKgD,QAAU,CAACN,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,IAIjCpD,EAAE8C,OAAOQ,UAAY,CAOnBZ,UAAW,SAASa,GAClB,OAAOlD,KAAKmD,WAAWD,EAAME,UAa/BD,WAAY,SAASD,GACnB,IAAI5C,EAASN,KAAKgD,QAClB,IAAIxB,EAAI0B,EAAM1B,EAAGE,EAAIwB,EAAMxB,EAC3BwB,EAAM1B,EAAIlB,EAAO,GAAKkB,EAAIlB,EAAO,GAAKoB,EAAIpB,EAAO,GACjD4C,EAAMxB,EAAIpB,EAAO,GAAKkB,EAAIlB,EAAO,GAAKoB,EAAIpB,EAAO,GACjD,OAAO4C,GAQTG,YAAa,SAAUH,GACrB,IAAI5C,EAASN,KAAKgD,QAClB,OAAO,IAAIrD,EAAE2D,OACVJ,EAAM1B,EAAIlB,EAAO,GAAKA,EAAO,IAAMA,EAAO,IAC1C4C,EAAMxB,EAAIpB,EAAO,GAAKA,EAAO,IAAMA,EAAO,KAQ/C8C,MAAO,WACL,IAAI9C,EAASN,KAAKgD,QAClB,OAAO,IAAIrD,EAAE8C,OACXnC,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAC7BA,EAAO,GAAIA,EAAO,GAAIA,EAAO,KASjCuB,UAAW,SAASA,GAClB,GAAIA,IAAc0B,UAAW,CAC3B,OAAO,IAAI5D,EAAE2D,MAAMtD,KAAKgD,QAAQ,GAAIhD,KAAKgD,QAAQ,IAGnD,IAAIQ,EAAYC,EAChB,UAAW5B,IAAc,SAAU,CACjC2B,EAAaC,EAAa5B,MACrB,CACL2B,EAAa3B,EAAUL,EACvBiC,EAAa5B,EAAUH,EAGzB,OAAO1B,KAAK0D,KAAK,EAAG,EAAG,EAAG,EAAGF,EAAYC,IAQ3CE,MAAO,SAASA,EAAOC,GACrB,GAAID,IAAUJ,UAAW,CACvB,OAAO,IAAI5D,EAAE2D,MAAMtD,KAAKgD,QAAQ,GAAIhD,KAAKgD,QAAQ,IAGnD,IAAIa,EAAQC,EACZF,EAASA,GAAUjE,EAAEuD,MAAM,EAAG,GAC9B,UAAWS,IAAU,SAAU,CAC7BE,EAASC,EAASH,MACb,CACLE,EAASF,EAAMnC,EACfsC,EAASH,EAAMjC,EAGjB,OAAO1B,KACJ0D,KAAKG,EAAQ,EAAG,EAAGC,EAAQF,EAAOpC,EAAGoC,EAAOlC,GAC5CgC,KAAK,EAAG,EAAG,EAAG,GAAIE,EAAOpC,GAAIoC,EAAOlC,IAWzCqC,OAAQ,SAASC,EAAOJ,GACtB,IAAIK,EAAMC,KAAKD,IAAID,GACnB,IAAIG,EAAMD,KAAKC,IAAIH,GAEnBJ,EAASA,GAAU,IAAIjE,EAAE2D,MAAM,EAAG,GAElC,OAAOtD,KACJ0D,KAAKO,EAAKE,GAAMA,EAAKF,EAAKL,EAAOpC,EAAGoC,EAAOlC,GAC3CgC,KAAK,EAAG,EAAG,EAAG,GAAIE,EAAOpC,GAAIoC,EAAOlC,IAQzC0C,KAAM,WACJpE,KAAKgD,QAAQ,KAAO,EACpBhD,KAAKgD,QAAQ,KAAO,EACpB,OAAOhD,MAYT0D,KAAM,SAAShB,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,GAC5B,IAAIsB,EAAS,CAAC,GAAI,GAAI,IACtB,IAAIC,EAAMtE,KAAKgD,QACf,IAAIrC,EAAI,CACN,CAAC2D,EAAI,GAAIA,EAAI,GAAIA,EAAI,IACrB,CAACA,EAAI,GAAIA,EAAI,GAAIA,EAAI,IACrB,CAAM,EAAQ,EAAO,IAEvB,IAAIC,EAAQ,CACV,CAAC7B,EAAGE,EAAGE,GACP,CAACH,EAAGE,EAAGE,GACP,CAAC,EAAG,EAAG,IACNyB,EAGH,GAAI9B,GAAKA,aAAa/C,EAAE8C,OAAQ,CAC9B6B,EAAM5B,EAAEM,QACRuB,EAAQ,CACN,CAACD,EAAI,GAAIA,EAAI,GAAIA,EAAI,IACrB,CAACA,EAAI,GAAIA,EAAI,GAAIA,EAAI,IACrB,CAAM,EAAQ,EAAO,IAGzB,IAAK,IAAIG,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,IAAK,IAAIC,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1BF,EAAM,EACN,IAAK,IAAIG,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1BH,GAAO7D,EAAE8D,GAAGE,GAAKJ,EAAMI,GAAGD,GAE5BL,EAAOI,GAAGC,GAAKF,GAInBxE,KAAKgD,QAAU,CACbqB,EAAO,GAAG,GAAIA,EAAO,GAAG,GAAIA,EAAO,GAAG,GACtCA,EAAO,GAAG,GAAIA,EAAO,GAAG,GAAIA,EAAO,GAAG,IAExC,OAAOrE,OAOXL,EAAEW,OAAS,SAASoC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,GACjC,OAAO,IAAIpD,EAAE8C,OAAOC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,K,gBC1MrC,EAAQ,OACR,EAAQ,OACR,EAAQ,OAYRpD,EAAEiF,KAAK/E,QAAQ,CAMdsD,WAAY,SAAS7C,GACpB,GAAIN,KAAK6E,UAAW,CACnB,GAAIvE,EAAQ,CACXN,KAAK6E,UAAUxE,cAAcL,KAAMM,OAC7B,CAENN,KAAK6E,UAAU/E,oBAAoBE,MACnCA,KAAK8E,WAGP,OAAO9E,MASR+E,cAAe,SAASjC,GACvB,GAAK9C,KAAKgF,UAAYhF,KAAKgF,SAASC,SAClCjF,KAAKkF,KAAKF,UAAYhF,KAAKkF,KAAKF,SAASC,QAAU,CACpD,OAGDjF,KAAKmF,gBAAgBrC,MAMvB,IAAIsC,EAAM,CACRC,UAAe,UACfC,WAAe,WACfC,YAAe,WACfC,cAAe,YAGjB,IAAIC,EAAO,CACTJ,UAAe,YACfC,WAAe,YACfC,YAAe,YACfC,cAAe,aAGjB,SAASE,EAAShD,EAAGC,GACnB,IAAIgD,EAAKjD,EAAElB,EAAImB,EAAEnB,EAAGoE,EAAKlD,EAAEhB,EAAIiB,EAAEjB,EACjC,OAAOwC,KAAK2B,KAAKF,EAAKA,EAAKC,EAAKA,GAQlCjG,EAAEmG,QAAQC,SAAWpG,EAAEmG,QAAQE,OAA6C,CAE1EC,QAAS,CACPC,aAAc,0BAQhBC,WAAY,SAASC,GAKnBpG,KAAKqG,MAAQD,EAKbpG,KAAKgD,QAAU,KAKfhD,KAAKsG,YAAc,KAKnBtG,KAAKuG,gBAAkB,KAKvBvG,KAAKwG,uBAAyB,OAOhCC,SAAU,WACRzG,KAAKqG,MAAMK,GAAG,YAAa1G,KAAK2G,aAAc3G,MAE9CA,KAAKqG,MAAMO,QAAQC,UAAY7G,KAAKqG,MAAMO,QAAQC,UAC7C7G,KAAKqG,MAAMO,QAAQC,UAAY,IAAMlH,EAAEmG,QAAQC,SAASG,aACxDvG,EAAEmG,QAAQC,SAASG,aAExB,GAAIlG,KAAKqG,MAAMA,MAAO,CACpB1G,EAAEmH,QAAQC,SAAS/G,KAAKqG,MAAMA,MAAO1G,EAAEmG,QAAQC,SAASG,gBAO5Dc,YAAa,WACXhH,KAAKqG,MAAMY,IAAI,YAAajH,KAAK2G,aAAc3G,MAE/CA,KAAKqG,MAAMO,QAAQC,UAAY7G,KAAKqG,MAAMO,QAAQC,UAC/CK,QAAQ,IAAIC,OAAO,OAASxH,EAAEmG,QAAQC,SAASG,cAAe,IACjE,GAAIlG,KAAKqG,MAAMA,MAAO,CACpB1G,EAAEmH,QAAQM,YAAYpH,KAAKqG,MAAMA,MAAO1G,EAAEmG,QAAQC,SAASG,gBAO/DjB,MAAO,WACL,OAAOjF,KAAKqG,MAAMgB,YAOpBV,aAAc,SAASW,GACrB,IAAIC,EAAYD,EAAIE,cAAcC,WAAa,aAAeH,EAAIE,cAAcE,KAEhF1H,KAAKwG,uBAAyB,MAC9BxG,KAAKsG,YAAcgB,EAAIK,eAAevE,QACtCpD,KAAKuG,gBAAkBe,EAAIK,eAAevE,QAC1CpD,KAAKgD,QAAU,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAC/BrD,EAAEiI,SAASC,KAAKP,EAAIE,eAEpB7H,EAAEmH,QAAQC,SAAS/G,KAAKqG,MAAMxB,UAAU9C,WAAY,uBACpDpC,EAAEiI,SACClB,GAAGtF,SAAUqE,EAAK8B,GAAYvH,KAAK8H,QAAY9H,MAC/C0G,GAAGtF,SAAUgE,EAAImC,GAAavH,KAAK+H,WAAY/H,MAElD,GAAIA,KAAKqG,MAAMnB,KAAKF,SAASgD,UAAW,CAItChI,KAAKqG,MAAMnB,KAAKF,SAASiD,UACzBjI,KAAKwG,uBAAyB,KAEhCxG,KAAKqG,MAAMgB,WAAa,MAExB,GAAIrH,KAAKqG,MAAM6B,OAAQ,CACrBlI,KAAKqG,MAAM6B,OAAOC,SAGpBnI,KAAKoI,qBAAqBd,IAO5BQ,QAAS,SAASR,GAChB3H,EAAEiI,SAASC,KAAKP,GAEhB,IAAIe,EAASf,EAAIgB,SAAWhB,EAAIgB,QAAQC,QAAU,EAAIjB,EAAIgB,QAAQ,GAAKhB,EACvE,IAAIK,EAAiB3H,KAAKqG,MAAMnB,KAAKsD,2BAA2BH,GAGhE,GAAIf,EAAII,OAAS,cAAgB1H,KAAKqG,MAAMgB,WAAY,CACtD,IAAIoB,EAAyBzI,KAAKuG,gBAAgBmC,WAAWf,GAC7D,GAAIc,GAA0BzI,KAAKqG,MAAMnB,KAAK0B,QAAQ+B,aAAc,CAClE,QAIJ,IAAInH,EAAImG,EAAenG,EACvB,IAAIE,EAAIiG,EAAejG,EAEvB,IAAIiE,EAAKnE,EAAIxB,KAAKsG,YAAY9E,EAC9B,IAAIoE,EAAKlE,EAAI1B,KAAKsG,YAAY5E,EAG9B,GAAIiE,GAAMC,EAAI,CACZ,IAAK5F,KAAKqG,MAAMgB,WAAY,CAC1BrH,KAAKqG,MAAMgB,WAAa,KACxBrH,KAAKqG,MAAMuC,KAAK,YAAatB,GAE7BtH,KAAKqG,MAAMwC,eAGb7I,KAAKgD,QAAQ,IAAM2C,EACnB3F,KAAKgD,QAAQ,IAAM4C,EAEnB5F,KAAKsG,YAAY9E,EAAIA,EACrBxB,KAAKsG,YAAY5E,EAAIA,EAErB1B,KAAKqG,MAAMuC,KAAK,UAAWtB,GAC3BtH,KAAKqG,MAAMlD,WAAWnD,KAAKgD,SAC3BhD,KAAKqG,MAAMuC,KAAK,OAAQtB,KAQ5BS,WAAY,SAAST,GACnB,IAAIK,EAAiB3H,KAAKqG,MAAMnB,KAAKsD,2BAA2BlB,GAChE,IAAIrC,EAAQjF,KAAKiF,QAGjB,GAAIA,EAAO,CACTjF,KAAK8I,iBAAiB9I,KAAKgD,SAC3BhD,KAAKqG,MAAM7D,cACXxC,KAAKqG,MAAM0C,WACX/I,KAAKqG,MAAMlD,WAAW,MAEtBxD,EAAEiI,SAASC,KAAKP,GAIlB3H,EAAEiI,SAASX,IAAI7F,SAAU,sBAAuBpB,KAAK8H,QAAY9H,MACjEL,EAAEiI,SAASX,IAAI7F,SAAU,mBAAuBpB,KAAK+H,WAAY/H,MAEjEA,KAAKgJ,uBAGL,GAAI/D,EAAO,CACTjF,KAAKqG,MAAMuC,KAAK,UAAW,CACzBlD,SAAUA,EAAS1F,KAAKuG,gBAAiBoB,KAI3C,IAAIsB,EAAWjJ,KAAKqG,MAAMlG,eAC1BH,KAAKqG,MAAMlG,eAAiBR,EAAEuJ,KAAKC,QACnCxJ,EAAEuJ,KAAKE,kBAAiB,WACtBzJ,EAAEiI,SAASyB,QAAQ,CAAE3B,KAAM,UAC3B1H,KAAKqG,MAAMlG,eAAiB8I,IAC3BjJ,MAGLA,KAAKgD,QAAmB,KACxBhD,KAAKsG,YAAmB,KACxBtG,KAAKuG,gBAAmB,KACxBvG,KAAKqG,MAAMgB,WAAa,MAExB,GAAIrH,KAAKwG,uBAAwB,CAC/B,GAAIvB,EAAOtF,EAAEiI,SAAS0B,SAAS,CAAE5B,KAAM,UACvC1H,KAAKqG,MAAMnB,KAAKF,SAASuE,WAc7BT,iBAAkB,SAASxI,EAAQkJ,GACjC,IAAIpD,EAAOpG,KAAKqG,MAChB,IAAI5B,EAAGgF,EAAKC,EAEZ,IAAIC,EAAKhK,EAAEuD,MAAM5C,EAAO,GAAIA,EAAO,IAEnC,IAAIsJ,EAAMxD,EAAKlB,KAAK0B,QAAQgD,IAC5B,IAAIC,EAAiBD,EAAIC,eACzB,IAAIlG,EAAQiG,EAAIjG,MAAMyC,EAAKlB,KAAK4E,WAChC,IAAIC,EAAaH,EAAIG,WAErB,IAAIC,EAAOH,EAAexG,YAAYsG,EAAIhG,GACvCsG,SAASJ,EAAexG,YAAY1D,EAAEuD,MAAM,EAAG,GAAIS,IACtD,IAAIuG,GAAkBV,EAEtBpD,EAAKrF,QAAU,IAAIpB,EAAEwK,aAIrB,GAAI/D,EAAKgE,OAAQ,CACfZ,EAAOO,EAAWM,UAChBN,EAAWO,QAAQlE,EAAKmE,SAAS7G,KAAKsG,IACxC,GAAIE,EAAgB,CAClB9D,EAAKmE,QAAUf,EACfpD,EAAKgE,OAAO1G,KAAKiG,SAEd,GAAIvD,EAAKoE,QAAUpE,EAAKqE,OAAQ,CACrC,IAAIC,EAAUtE,EAAKoE,QAAUpE,EAAKqE,OAClC,IAAIE,EAAUvE,EAAKwE,SACnBpB,EAAOA,GAAQmB,EACf,IAAKhL,EAAEuJ,KAAK2B,QAAQF,EAAQ,IAAK,CAC/BA,EAAU,CAACA,GACXnB,EAAU,CAACA,GAEb,IAAK/E,EAAI,EAAGgF,EAAMkB,EAAQpC,OAAQ9D,EAAIgF,EAAKhF,IAAK,CAC9C+E,EAAK/E,GAAK+E,EAAK/E,IAAM,GACrB,IAAK,IAAIC,EAAI,EAAGoG,EAAKH,EAAQlG,GAAG8D,OAAQ7D,EAAIoG,EAAIpG,IAAK,CACnDgF,EAAaiB,EAAQlG,GAAGC,GACxB8E,EAAK/E,GAAGC,GAAKqF,EACVM,UAAUN,EAAWO,QAAQZ,GAAQhG,KAAKsG,IAC7C,GAAIE,EAAgB,CAClB9D,EAAKrF,QAAQiF,OAAO2E,EAAQlG,GAAGC,IAC/B,GAAIgG,EAAMjG,GAAGC,GAAI,CACbgG,EAAMjG,GAAGC,GAAGhB,KAAKiG,OAM7B,OAAOH,GAUTpB,qBAAsB,WACpB,GAAIpI,KAAKqG,MAAM0E,UAAW,CACxB/K,KAAKqG,MAAM2E,WAAahL,KAAKqG,MAAM0E,UACnC/K,KAAKqG,MAAM0E,UAAYpL,EAAEuJ,KAAK+B,MAAK,WACjC,OAAOjL,KAAKgF,SAAS8D,iBAAiB9I,KAAKgF,SAAShC,QAAS,MAC5DhD,KAAKqG,YACH,GAAIrG,KAAKqG,MAAM6E,WAAY,CAChClL,KAAKqG,MAAM8E,YAAcnL,KAAKqG,MAAM6E,WACpClL,KAAKqG,MAAM6E,WAAavL,EAAEuJ,KAAK+B,MAAK,WAClC,OAAOjL,KAAKgF,SAAS8D,iBAAiB9I,KAAKgF,SAAShC,QAAS,MAC5DhD,KAAKqG,SAQZ2C,qBAAsB,WACpB,GAAIhJ,KAAKqG,MAAM2E,WAAY,CACzBhL,KAAKqG,MAAM0E,UAAY/K,KAAKqG,MAAM2E,kBAC3BhL,KAAKqG,MAAM2E,gBACb,GAAIhL,KAAKqG,MAAM8E,YAAa,CACjCnL,KAAKqG,MAAM6E,WAAalL,KAAKqG,MAAM8E,mBAC5BnL,KAAKqG,MAAM8E,gBAWxBxL,EAAEmG,QAAQC,SAASqF,cAAgB,SAASrL,GAC1CA,EAAMiF,SAAW,IAAIrF,EAAEmG,QAAQC,SAAShG,GACxC,OAAOA,GAQTJ,EAAEiF,KAAK3B,UAAUmI,cAAgB,WAC/B,OAAOzL,EAAEmG,QAAQC,SAASqF,cAAcpL,OAI1CL,EAAEiF,KAAKyG,aAAY,WACjB,GAAIrL,KAAK4G,QAAQ0E,UAAW,CAE1BtL,KAAK4G,QAAQ2E,YAAc,KAE3B,GAAIvL,KAAKgF,SAAU,CACjBhF,KAAKgF,SAASuE,aACT,CACL5J,EAAEmG,QAAQC,SAASqF,cAAcpL,MACjCA,KAAKgF,SAASuE,eAEX,GAAIvJ,KAAKgF,SAAU,CACxBhF,KAAKgF,SAASiD,cAIlBuD,EAAOC,QAAU9L,EAAEiF,KAAK8G,M,WCxZxB/L,EAAEgM,cAAcC,OAASjM,EAAEkM,aAAa7F,OAAO,CAC7CY,QAAS,CACPC,UAAW,kCAGbiF,MAAO,SAAUC,GACfpM,EAAEkM,aAAa5I,UAAU6I,MAAME,KAAKhM,KAAM+L,GAC1C,GAAI/L,KAAKqG,OAASrG,KAAK4G,QAAQqF,UAAW,CACxCjM,KAAKqG,MAAM6F,MAAMC,OAASxM,EAAEgM,cAAcC,OAAOQ,cAC/CpM,KAAK4G,QAAQyF,WAWrB1M,EAAEgM,cAAcC,OAAOQ,cAAgB,CACrC,cAAe,cAAe,cAAe,eAO/CzM,EAAEgM,cAAcW,aAAe3M,EAAEgM,cAAcC,OAAO5F,OAAO,CAC3DY,QAAS,CACPC,UAAW,4DAGbiF,MAAO,SAAUC,GACfpM,EAAEkM,aAAa5I,UAAU6I,MAAME,KAAKhM,KAAM+L,GAC1C,GAAI/L,KAAKqG,OAASrG,KAAK4G,QAAQqF,UAAW,CACxCjM,KAAKqG,MAAM6F,MAAMC,OAAS,iBAKhCxM,EAAEmG,QAAQ6F,cAAgBhM,EAAEmG,QAAQE,OAAO,CAEzCY,QAAS,CACP2F,SAAU,KACVC,QAAU,KACVC,eAAgB,KAChBC,QAAU,GAGVC,eAAgB,CACdC,OAAa,EACbC,UAAa,UACbC,MAAa,UACbC,YAAa,EACbC,OAAa,EACbC,QAAa,GACbhB,UAAa,MAIfiB,cAAe,CACbF,OAAW,EACXC,QAAW,EACXE,UAAW,CAAC,EAAG,GACfC,KAAW,MACXC,OAAW,MAIbC,oBAAqB,CACnBN,OAAW,EACXC,QAAW,EACXhB,UAAW,MAGbsB,aAAc,GAGdC,WAAc,EAEdC,YAAmB9N,EAAEgM,cAAcC,OACnC8B,kBAAmB/N,EAAEgM,cAAcW,cASrCnG,WAAY,SAASC,GAEnBpG,KAAKqG,MAAQD,EACbpG,KAAKkF,KAAQ,KAGblF,KAAK2N,cAAkB,KACvB3N,KAAK4N,cAAkB,KACvB5N,KAAK6N,gBAAkB,KAGvB7N,KAAK8N,gBAAoB,KACzB9N,KAAK+N,aAAoB,KACzB/N,KAAKgO,OAAoB,EACzBhO,KAAKiO,OAAoBtO,EAAEuD,MAAM,EAAG,GACpClD,KAAKkO,aAAoB,EACzBlO,KAAKmO,cAAoB,EACzBnO,KAAKoO,cAAoB,EACzBpO,KAAKqO,eAAoB,KACzBrO,KAAKsO,kBAAoB,KAGzBtO,KAAKgD,QAAmB,IAAIrD,EAAE8C,OAAO,EAAG,EAAG,EAAG,EAAG,EAAG,GACpDzC,KAAKuO,iBAAmB,IAAI5O,EAAE8C,OAAO,EAAG,EAAG,EAAG,EAAG,EAAG,GAGpDzC,KAAKwO,eAAkB,KACvBxO,KAAKyO,MAAkB,KACvBzO,KAAK0O,UAAkB,GACvB1O,KAAK2O,YAAkB,MASzBpF,OAAQ,SAAS3C,GACf,GAAI5G,KAAKqG,MAAMnB,KAAM,CACnBlF,KAAKkF,KAAOlF,KAAKqG,MAAMnB,KACvB,GAAI0B,EAAS,CACX5G,KAAK4O,WAAWhI,GAElBjH,EAAEmG,QAAQ7C,UAAUsG,OAAOyC,KAAKhM,QAQpCyG,SAAU,WACRzG,KAAK6O,kBACL7O,KAAKqG,MACFK,GAAG,YAAa1G,KAAK2G,aAAc3G,MACnC0G,GAAG,UAAa1G,KAAK+H,WAAc/H,OAOxCgH,YAAa,WACXhH,KAAK8O,gBACL9O,KAAKqG,MACFY,IAAI,YAAajH,KAAK2G,aAAc3G,MACpCiH,IAAI,UAAajH,KAAK+H,WAAc/H,MACvCA,KAAKwO,eAAiB,KACtBxO,KAAKyO,MAAQ,KACbzO,KAAK0O,UAAY,IAQnBE,WAAY,SAAShI,GACnB,IAAIoB,EAAUhI,KAAK+O,SACnB,GAAI/G,EAAS,CACXhI,KAAKiI,UAGPjI,KAAK4G,QAAUjH,EAAEgM,cAAcqD,MAAM,GACnCrP,EAAEmG,QAAQ6F,cAAc1I,UAAU2D,QAClCA,GAEF,GAAIoB,EAAS,CACXhI,KAAKuJ,SAGP,OAAOvJ,MAST+D,OAAQ,SAASC,EAAOJ,GACtB,OAAO5D,KAAKqC,UAAU2B,EAAO,KAAMJ,IASrCD,MAAO,SAASA,EAAOC,GACrB,UAAWD,IAAU,SAAU,CAC7BA,EAAQhE,EAAEuD,MAAMS,EAAOA,GAEzB,OAAO3D,KAAKqC,UAAU,EAAGsB,EAAO,KAAMC,IAWxCvB,UAAW,SAAS2B,EAAOL,EAAOsL,EAAgBC,GAChD,IAAIC,EAAanP,KAAKqG,MAAM+I,YAC5BH,EAAiBA,GAAkBE,EACnCD,EAAiBA,GAAkBC,EACnCnP,KAAKkF,KAAOlF,KAAKqG,MAAMnB,KACvBlF,KAAK8I,iBAAiB9I,KAAKqG,MAAOrC,EAAOL,EAAOsL,EAAgBC,GAChElP,KAAK8I,iBAAiB9I,KAAKyO,MAAOzK,EAAOL,EAAOsL,EAAgBC,GAChElP,KAAK8I,iBAAiB9I,KAAK2O,YAAa3K,EAAOL,EAAOsL,EAAgBC,GACtElP,KAAKqP,kBACL,OAAOrP,MAOT8E,QAAS,WACP,IAAIxE,EAASN,KAAKgD,QAGlB,IAAK,IAAIyB,EAAI,EAAGgF,EAAMzJ,KAAK0O,UAAUnG,OAAQ9D,EAAIgF,EAAKhF,IAAK,CACzD,IAAI6K,EAAUtP,KAAK0O,UAAUjK,GAC7B,GAAI6K,IAAYtP,KAAK4N,cAAe,CAClC0B,EAAQlF,OAAS9J,EAAO+B,UAAUiN,EAAQC,eAC1CD,EAAQ9M,eAIZlC,EAASA,EAAO8C,QAAQgB,OAExBpE,KAAKwP,gBAAgBlP,GACrBN,KAAKqG,MAAMuC,KAAK,YAAa,CAAE7I,MAAOC,KAAKqG,SAO7CmJ,gBAAiB,SAASlP,GACxBN,KAAKqG,MAAMlD,WAAW7C,EAAO0C,SAC7BhD,KAAKyO,MAAMtL,WAAW7C,EAAO0C,SAE7B,GAAIhD,KAAK4G,QAAQ2F,SAAU,CACzBvM,KAAK2O,YAAYxL,WAAW7C,EAAO0C,WAQvCyM,OAAQ,WAEN,IAAI1D,EAAM/L,KAAKkF,KACf,IAAI5E,EAASN,KAAKgD,QAAQI,QAC1B,IAAIY,EAAQhE,KAAKgO,OACjB,IAAIrK,EAAQ3D,KAAKiO,OAAO7K,QAExBpD,KAAK0P,uBAGL,IAAK,IAAIjL,EAAI,EAAGgF,EAAMzJ,KAAK0O,UAAUnG,OAAQ9D,EAAIgF,EAAKhF,IAAK,CACzD,IAAI6K,EAAUtP,KAAK0O,UAAUjK,GAC7B6K,EAAQ/E,QAAUwB,EAAI4D,mBAAmBL,EAAQlF,eAC1CkF,EAAQC,cACfD,EAAQM,SAGV5P,KAAKgD,QAAUrD,EAAEW,OAAO,EAAG,EAAG,EAAG,EAAG,EAAG,GACvCN,KAAKiO,OAAUtO,EAAEuD,MAAM,EAAG,GAC1BlD,KAAKgO,OAAU,EAEfhO,KAAKqP,kBAELtD,EAAI/G,SAASuE,SACbvJ,KAAKqG,MAAMuC,KAAK,cAAe,CAC7BtI,OAAQA,EACRqD,MAAOA,EACP4I,SAAUvI,EAEVjE,MAAOC,KAAKqG,SAUhBwJ,MAAO,WACL7P,KAAK8P,WAAa,KAClB,GAAI9P,KAAK+O,SAAU,CACjB,GAAI/O,KAAKyO,MAAO,CACdzO,KAAKwO,eAAeuB,YAAY/P,KAAKyO,OAEvCzO,KAAKyO,MAAQzO,KAAKgQ,sBAAsBC,MAAMjQ,KAAKwO,gBACnDxO,KAAKqP,oBAQTA,gBAAiB,WACf,IAAIa,EAAgBlQ,KAAKwO,eAEzBxO,KAAK8P,WAAa9P,KAAKyO,MAAM0B,YAE7B,GAAInQ,KAAK2O,YAAa,CACpB3O,KAAKwO,eAAeuB,YAAY/P,KAAK2O,aAGvC,GAAI3O,KAAK6N,gBAAiB,CACxB7N,KAAKwO,eAAeuB,YAAY/P,KAAK6N,iBAGvC7N,KAAK2O,YAAc3O,KAAK6N,gBAAkB,KAE1C,IAAK,IAAIpJ,EAAIzE,KAAK0O,UAAUnG,OAAS,EAAG9D,GAAK,EAAGA,IAAK,CACnDyL,EAAcH,YAAY/P,KAAK0O,UAAUjK,IAG3CzE,KAAK6O,mBAOPa,qBAAsB,WACpB1P,KAAKqG,MAAMlD,WAAW,MACtBnD,KAAKyO,MAAMtL,WAAW,MAEtBnD,KAAK8I,iBAAiB9I,KAAKqG,OAC3BrG,KAAK8I,iBAAiB9I,KAAKyO,OAE3B,GAAIzO,KAAK4G,QAAQ2F,SAAU,CACzBvM,KAAK2O,YAAYxL,WAAW,MAC5BnD,KAAK8I,iBAAiB9I,KAAK2O,YAAa3O,KAAKgO,OAAQ,KAAMhO,KAAKoQ,WAWpEC,oBAAqB,SAASrM,EAAOL,EAAOsL,EAAgBC,GAC1D,IAAInD,EAAS/L,KAAKkF,KAClB,IAAIoL,EAASvE,EAAIwE,cAAgBvQ,KAAK4G,QAAQ8F,QAC9C,IAAIpM,EAASX,EAAEW,OAAO,EAAG,EAAG,EAAG,EAAG,EAAG,GACrC,IAAIsD,EAEJI,EAAQA,GAAShE,KAAKgO,QAAU,EAChCrK,EAAQA,GAAS3D,KAAKiO,QAAUtO,EAAEuD,MAAM,EAAG,GAE3C,KAAMS,EAAMnC,IAAM,GAAKmC,EAAMjC,IAAM,GAAI,CACrCwN,EAAcA,GAAelP,KAAK+N,aAClCnK,EAASmI,EAAIzB,QAAQ4E,EAAaoB,GAClChQ,EAASA,EACNoD,KAAK/D,EAAEW,OAAO,EAAG,EAAG,EAAG,EAAGsD,EAAOpC,EAAGoC,EAAOlC,IAC3CgC,KAAK/D,EAAEW,OAAOqD,EAAMnC,EAAG,EAAG,EAAGmC,EAAMjC,EAAG,EAAG,IACzCgC,KAAK/D,EAAEW,OAAO,EAAG,EAAG,EAAG,GAAIsD,EAAOpC,GAAIoC,EAAOlC,IAGlD,GAAIsC,EAAO,CACTiL,EAAiBA,GAAkBjP,KAAK8N,gBACxClK,EAASmI,EAAIzB,QAAQ2E,EAAgBqB,GACrChQ,EAASA,EAAOyD,OAAOC,EAAOJ,GAAQQ,OAGxC,OAAO9D,GAWTkQ,gBAAiB,SAAS9G,EAAQpJ,EAAQyL,EAAKuE,GAC7C,OAAOvE,EAAI1B,UAAU/J,EAAO+B,UAC1B0J,EAAIzB,QAAQZ,EAAQ4G,IAAQA,IAchCxH,iBAAkB,SAAS1C,EAAMpC,EAAOL,EAAOsL,EAAgBC,GAC7D,IAAInD,EAAM3F,EAAKlB,KACf,IAAIoL,EAAOvE,EAAIwE,cAAgBvQ,KAAK4G,QAAQ8F,QAC5C,IAAIjI,EAAGgF,EAEP,IAAIgH,EAAkBzQ,KAAKuO,iBACzBvO,KAAKqQ,oBAAoBrM,EAAOL,EAAOsL,EAAgBC,GAIzD,GAAI9I,EAAKgE,OAAQ,CACfhE,EAAKmE,QAAUvK,KAAKwQ,gBAClBpK,EAAKmE,QAASkG,EAAiB1E,EAAKuE,QACjC,GAAIlK,EAAKoE,QAAUpE,EAAKqE,OAAQ,CACrC,IAAIE,EAAUvE,EAAKwE,SACnBxE,EAAKrF,QAAU,IAAIpB,EAAEwK,aAErB,IAAKxK,EAAEuJ,KAAK2B,QAAQF,EAAQ,IAAK,CAC/BA,EAAU,CAACA,GAEb,IAAKlG,EAAI,EAAGgF,EAAMkB,EAAQpC,OAAQ9D,EAAIgF,EAAKhF,IAAK,CAC9C,IAAK,IAAIC,EAAI,EAAGoG,EAAKH,EAAQlG,GAAG8D,OAAQ7D,EAAIoG,EAAIpG,IAAK,CACnDiG,EAAQlG,GAAGC,GAAK1E,KAAKwQ,gBACnB7F,EAAQlG,GAAGC,GAAI+L,EAAiB1E,EAAKuE,GACvClK,EAAKrF,QAAQiF,OAAO2E,EAAQlG,GAAGC,MAKrC0B,EAAKsK,UAQP7B,gBAAiB,WACf,IAAI9C,EAAM/L,KAAKkF,KACflF,KAAKwO,eAAiBxO,KAAKwO,iBACL,IAAI7O,EAAEgR,YAAaV,MAAMlE,GAC/C/L,KAAKyO,MAAQzO,KAAKyO,OACLzO,KAAKgQ,sBAAsBC,MAAMjQ,KAAKwO,gBAEnD,GAAIxO,KAAK4G,QAAQ4F,QAAS,CACxBxM,KAAK0O,UAAY,GACjB,IAAK,IAAIjK,EAAI,EAAGA,EAAIzE,KAAK4G,QAAQ4G,WAAY/I,IAAK,CAEhDzE,KAAK0O,UAAUkC,KACb5Q,KAAK6Q,eAAe7Q,KAAKyO,MAAM7D,SAAS,GAAGnG,GAAIA,EAAI,EAAGA,GACrDwL,MAAMjQ,KAAKwO,kBAKlB,GAAIxO,KAAK4G,QAAQ2F,SAAU,CAEzBvM,KAAK8Q,4BAQTA,wBAAyB,WACvB,IAAI/E,EAAU/L,KAAKkF,KACnB,IAAIyF,EAAU3K,KAAKyO,MAAM7D,SAAS,GAElC,IAAImG,EAAW,IAAIpR,EAAEqR,QAClBrG,EAAQ,GAAGsG,IAAMtG,EAAQ,GAAGsG,KAAO,GACnCtG,EAAQ,GAAGuG,IAAMvG,EAAQ,GAAGuG,KAAO,GAEtC,IAAIC,EAAW,IAAIxR,EAAEqR,QAClBrG,EAAQ,GAAGsG,IAAMtG,EAAQ,GAAGsG,KAAO,GACnCtG,EAAQ,GAAGuG,IAAMvG,EAAQ,GAAGuG,KAAO,GAEtC,IAAIE,EAAkBrF,EAAI4D,mBACxBhQ,EAAEgM,cAAc0F,YACdtF,EAAIuF,mBAAmBP,GACvBhF,EAAIuF,mBAAmBH,GACvBnR,KAAK4G,QAAQ2G,eAGjBvN,KAAK2O,YAAc,IAAIhP,EAAE4R,SAAS,CAACJ,EAAUC,GAC3CpR,KAAK4G,QAAQ0G,qBAAqB2C,MAAMjQ,KAAKwO,gBAC/C,IAAIgD,EAAoBxR,KAAK4G,QAAQ8G,kBACrC1N,KAAK6N,gBAAkB,IAAI2D,EAAkBJ,EAC3CpR,KAAK4G,QAAQ+F,gBACZsD,MAAMjQ,KAAKwO,gBACX9H,GAAG,YAAa1G,KAAKyR,eAAgBzR,MAExCA,KAAK8N,gBAAkB,IAAInO,EAAEqR,QAC1BG,EAASF,IAAMF,EAAOE,KAAO,GAC7BE,EAASD,IAAMH,EAAOG,KAAO,GAGhClR,KAAK0O,UAAUkC,KAAK5Q,KAAK6N,kBAO3B6D,mBAAoB,WAClB,IAAI/G,EAAU3K,KAAKyO,MAAM7D,SAAS,GAClC,IAAI+G,EAAKhH,EAAQ,GACjB,IAAIiH,EAAKjH,EAAQ,GAEjB,OAAO,IAAIhL,EAAEqR,QACVW,EAAGV,IAAMW,EAAGX,KAAO,GACnBU,EAAGT,IAAMU,EAAGV,KAAO,IASxBO,eAAgB,SAASnK,GACvB,IAAIyE,EAAM/L,KAAKkF,KAEf6G,EAAI/G,SAASiD,UAEbjI,KAAK4N,cAAoB,KACzB5N,KAAKsO,kBAAoBvC,EAAIuF,mBAAmBtR,KAAK0R,sBACrD1R,KAAKqO,eAAoB/G,EAAIuK,WAC7B7R,KAAK8R,eAAoB9R,KAAKgD,QAAQI,QAEtCpD,KAAKgO,OAAS,EACdhO,KAAKqG,MAAMnB,KACRwB,GAAG,YAAa1G,KAAK+R,UAAe/R,MACpC0G,GAAG,UAAa1G,KAAKgS,aAAchS,MAEtCA,KAAKiS,eACLjS,KAAKqG,MACFuC,KAAK,iBAAoB,CAAE7I,MAAOC,KAAKqG,QACvCuC,KAAK,cAAe,CAAE7I,MAAOC,KAAKqG,MAAOkG,SAAU,KAOxDwF,UAAW,SAASzK,GAClB,IAAIpG,EAAMoG,EAAIuK,WACd,IAAIK,EAAWlS,KAAKqO,eACpB,IAAIzK,EAAW5D,KAAKsO,kBAGpBtO,KAAKgO,OAAS9J,KAAKiO,MAAMjR,EAAIQ,EAAIkC,EAAOlC,EAAGR,EAAIM,EAAIoC,EAAOpC,GAC5C0C,KAAKiO,MAAMD,EAASxQ,EAAIkC,EAAOlC,EAAGwQ,EAAS1Q,EAAIoC,EAAOpC,GAEpExB,KAAKgD,QAAUhD,KAAK8R,eACjB1O,QACAW,OAAO/D,KAAKgO,OAAQpK,GACpBQ,OAEHpE,KAAK8E,UACL9E,KAAKqG,MAAMuC,KAAK,SAAU,CAAE7I,MAAOC,KAAKqG,MAAOkG,SAAUvM,KAAKgO,UAOhEgE,aAAc,SAAS1K,GACrBtH,KAAKqG,MAAMnB,KACR+B,IAAI,YAAajH,KAAK+R,UAAW/R,MACjCiH,IAAI,UAAajH,KAAKgS,aAAchS,MAEvC,IAAIgE,EAAQhE,KAAKgO,OACjBhO,KAAKyP,SACLzP,KAAKqG,MAAMuC,KAAK,YAAa,CAAE7I,MAAOC,KAAKqG,MAAOkG,SAAUvI,KAO9DoO,cAAe,SAAS9K,GACtB,IAAI+K,EAAS/K,EAAIgL,OACjB,IAAIvG,EAAM/L,KAAKkF,KAEf6G,EAAI/G,SAASiD,UAEbjI,KAAK2N,cAAgB0E,EAErBrS,KAAK4N,cAAgB5N,KAAK0O,WAAW2D,EAAOzL,QAAQyF,MAAQ,GAAK,GACjErM,KAAK+N,aAAgB/N,KAAK4N,cAAc7C,YAExC/K,KAAK8R,eAAiB9R,KAAKgD,QAAQI,QACnCpD,KAAKiS,eAELjS,KAAKkF,KACFwB,GAAG,YAAa1G,KAAKuS,SAAavS,MAClC0G,GAAG,UAAa1G,KAAKwS,YAAaxS,MACrCA,KAAKkO,aAAgBlO,KAAK4N,cAAcxD,OAAO1B,WAAW1I,KAAK2N,cAAcvD,QAC7EpK,KAAKmO,cAAgBnO,KAAK4N,cAAcxD,OAAO5I,EAAIxB,KAAK2N,cAAcvD,OAAO5I,EAC7ExB,KAAKoO,cAAgBpO,KAAK4N,cAAcxD,OAAO1I,EAAI1B,KAAK2N,cAAcvD,OAAO1I,EAE7E1B,KAAKqG,MACFuC,KAAK,iBAAkB,CAAE7I,MAAOC,KAAKqG,QACrCuC,KAAK,aAAc,CAAE7I,MAAOC,KAAKqG,MAAO1C,MAAOhE,EAAEuD,MAAM,EAAG,KAE7D,GAAIlD,KAAK2O,YAAa,CACpB3O,KAAKkF,KAAK6K,YAAY/P,KAAK2O,aAE7B,GAAI3O,KAAK6N,gBAAiB,CACxB7N,KAAKkF,KAAK6K,YAAY/P,KAAK6N,mBAU/B0E,SAAU,SAASjL,GACjB,IAAImL,EAAczS,KAAK4N,cAAcxD,OACrC,IAAIsI,EAAQC,EACZ,GAAI3S,KAAK4G,QAAQ6F,eAAgB,CAC/BiG,EAASD,EAAY/J,WAAWpB,EAAIuK,YAAc7R,KAAKkO,aACvDyE,EAASD,MACJ,CACLA,GAAUD,EAAYjR,EAAI8F,EAAIuK,WAAWrQ,GAAKxB,KAAKmO,cACnDwE,GAAUF,EAAY/Q,EAAI4F,EAAIuK,WAAWnQ,GAAK1B,KAAKoO,cAGrDpO,KAAKiO,OAAS,IAAItO,EAAE2D,MAAMoP,EAAQC,GAGlC3S,KAAKgD,QAAUhD,KAAK8R,eACjB1O,QACAO,MAAM3D,KAAKiO,OAAQwE,GAEtBzS,KAAK8E,UACL9E,KAAKqG,MAAMuC,KAAK,QAAS,CACvB7I,MAAOC,KAAKqG,MAAO1C,MAAO3D,KAAKiO,OAAO7K,WAQ1CoP,YAAa,SAASlL,GACpBtH,KAAKkF,KACF+B,IAAI,YAAajH,KAAKuS,SAAavS,MACnCiH,IAAI,UAAajH,KAAKwS,YAAaxS,MAEtC,GAAIA,KAAK2O,YAAa,CACpB3O,KAAKkF,KAAK0N,SAAS5S,KAAK2O,aAE1B,GAAI3O,KAAK6N,gBAAiB,CACxB7N,KAAKkF,KAAK0N,SAAS5S,KAAK6N,iBAG1B7N,KAAKyP,SACLzP,KAAKqG,MAAMuC,KAAK,WAAY,CAC1B7I,MAAOC,KAAKqG,MAAO1C,MAAO3D,KAAKiO,OAAO7K,WAO1C6O,aAAc,WACZjS,KAAKwO,eAAeqE,WAAU,SAAS9S,GACrCA,EAAM8I,kBAER,IAAK,IAAIpE,EAAI,EAAGgF,EAAMzJ,KAAK0O,UAAUnG,OAAQ9D,EAAIgF,EAAKhF,IAAK,CACzD,IAAI6K,EAAUtP,KAAK0O,UAAUjK,GAC7B6K,EAAQC,cAAgBD,EAAQlF,OAAOhH,UAS3C4M,oBAAqB,WACnB,GAAIhQ,KAAK8P,WAAY,CACnB,OAAOnQ,EAAEmT,QAAQC,gBACf/S,KAAK8P,WAAY9P,KAAK4G,QAAQsG,mBAC3B,CACL,OAAO,IAAIvN,EAAEqT,UACXhT,KAAKqG,MAAM4M,YAAajT,KAAK4G,QAAQsG,iBAY3C2D,eAAgB,SAASnH,EAAQhC,EAAM2E,GACrC,IAAI6G,EAAclT,KAAK4G,QAAQ6G,YAC/B,IAAI4E,EAAS,IAAIa,EAAYxJ,EAC3B/J,EAAEuJ,KAAKlD,OAAO,GAAIhG,KAAK4G,QAAQ+F,eAAgB,CAC7C9F,UAAW,8CACAwF,EAAQ,iBAAmB3E,EACtC2E,MAAWA,EACX3E,KAAWA,KAIf2K,EAAO3L,GAAG,YAAa1G,KAAKoS,cAAepS,MAC3C,OAAOqS,GAOTvD,cAAe,WACb9O,KAAKkF,KAAK6K,YAAY/P,KAAKwO,iBAO7B7H,aAAc,WACZ3G,KAAK8O,iBAOP/G,WAAY,SAAST,GACnB,IAAI6L,EAAOnT,KAAKyO,MAChB,IAAInO,GAAUgH,EAAIvH,MAAQuH,EAAIvH,MAAQC,KAAKqG,OAAOrB,SAAShC,QAAQoQ,QAEnE,IAAKD,EAAKnO,SAAU,CAClBmO,EAAKnO,SAAW,IAAIrF,EAAEmG,QAAQC,SAASoN,GAEzCA,EAAKnO,SAASuE,SACdvJ,KAAKkF,KAAK0N,SAASO,GACnBA,EAAKnO,SAAS8D,iBAAiBxI,GAC/B6S,EAAK3Q,cACL2Q,EAAKpK,WACLoK,EAAKnO,SAASiD,UAEdjI,KAAKkF,KAAK0N,SAAS5S,KAAKwO,gBACxBxO,KAAKqP,kBAELrP,KAAKqG,MAAMuC,KAAK,cAAe,CAC7BjF,MAAOhE,EAAEuD,MAAM,EAAG,GAClBqJ,SAAU,EACVjM,OAAQX,EAAEW,OAAOgC,MAAMiB,UAAWjD,GAClCuB,UAAWlC,EAAEuD,MAAM5C,EAAO,GAAIA,EAAO,IACrCP,MAAOC,KAAKqG,WAMlB1G,EAAEiF,KAAKyG,aAAY,WACjB,GAAIrL,KAAK4G,QAAQvE,UAAW,CAC1BrC,KAAKqC,UAAY,IAAI1C,EAAEmG,QAAQ6F,cAAc3L,KAAMA,KAAK4G,QAAQvE,gB,WCxxBpE1C,EAAE0T,IAAIxT,SAASF,EAAEiB,QAAQ0S,IAAM,GAAK,CAKnCxT,oBAAqB,SAASC,GAC7B,GAAIA,EAAMwT,MAAO,CAGhBxT,EAAMwT,MAAM7M,GAAK,MACjB3G,EAAMsG,MAAMmN,YAAYzT,EAAMwT,OAC9BxT,EAAMwT,MAAQ,OAShBlT,cAAe,SAASN,EAAOO,GAC9B,IAAImT,EAAO1T,EAAMwT,MAEjB,IAAKE,EAAM,CACVA,EAAO9T,EAAE0T,IAAIK,OAAO,QACpB3T,EAAMsG,MAAMsN,YAAYF,GACxBA,EAAKvH,MAAM0H,SAAW,oBACtB7T,EAAMwT,MAAQE,EAIf,IAAII,EAAKvT,EAAO,GAAGwT,QAAQ,GAAK,IAAMxT,EAAO,GAAGwT,QAAQ,GAAK,IAC5DxT,EAAO,GAAGwT,QAAQ,GAAK,IAAMxT,EAAO,GAAGwT,QAAQ,GAAK,OACrD,IAAIC,EAAS7P,KAAK8P,MAAM1T,EAAO,IAAIwT,UAAY,KAC9C5P,KAAK8P,MAAM1T,EAAO,IAAIwT,UAAY,GAEnC,IAAIG,EAAIjU,KAAKqG,MAAM6F,MACnB,IAAIgI,EAAIC,WAAWF,EAAEG,MACrB,IAAIC,EAAIF,WAAWF,EAAEK,KACrB,IAAIC,EAAIJ,WAAWF,EAAE1S,OACrB,IAAIiT,EAAIL,WAAWF,EAAExS,QAErB,GAAIgT,MAAMP,GAAUA,EAAI,EACxB,GAAIO,MAAMJ,GAAUA,EAAI,EACxB,GAAII,MAAMF,KAAOA,EAAGA,EAAI,EACxB,GAAIE,MAAMD,KAAOA,EAAGA,EAAI,EAExB,IAAI5Q,IAAWsQ,EAAIK,EAAI,IAAKT,QAAQ,GAAK,MAAQO,EAAIG,EAAI,IAAKV,QAAQ,GAEtEL,EAAK/M,GAAK,IACV+M,EAAKnT,OAASuT,EACdJ,EAAK7P,OAASA,EACd6P,EAAKM,OAASA,EACdN,EAAK/M,GAAK,S,WCrDZ/G,EAAE0T,IAAIxT,QAAQ,CAKbC,oBAAqB,SAASC,GAC7BA,EAAMsG,MAAMqO,eAAe,KAAM,YAAa,KAQ/CrU,cAAe,SAASN,EAAOO,GAC9BP,EAAMsG,MAAMqO,eAAe,KAAM,YAChC,UAAYpU,EAAOqU,KAAK,KAAO,S,WCZlChV,EAAEgM,cAAgB,GAUlBhM,EAAEgM,cAAc0F,YAAc,SAASuD,EAAOC,EAAOC,GACnD,IAAIC,EAAQ,EAAID,EAASF,EAAMlM,WAAWmM,GAC1C,OAAO,IAAIlV,EAAE2D,MACXsR,EAAMpT,GAAKqT,EAAMrT,EAAIoT,EAAMpT,GAAKuT,EAChCH,EAAMlT,GAAKmT,EAAMnT,EAAIkT,EAAMlT,GAAKqT,IAQpCpV,EAAEgM,cAAcqD,MAAQ,WACtB,IAAIvK,EAAI,EACR,IAAIuQ,EAAKxQ,EACT,IAAIyQ,EAAMC,UAAUzQ,GAEpB,SAAS0Q,EAASC,GAChB,OAAOC,OAAOpS,UAAUqS,SAAStJ,KAAKoJ,KAAY,kBAKpD,IAAI9C,EAAS4C,UAAU,GAEvB,MAAOD,EAAK,CACVA,EAAMC,UAAUzQ,KAChB,IAAKuQ,KAAOC,EAAK,CACf,IAAKA,EAAIM,eAAeP,GAAM,CAC5B,SAGFxQ,EAAMyQ,EAAID,GAEV,GAAIG,EAAS3Q,IAAQ2Q,EAAS7C,EAAO0C,IAAM,CACzC1C,EAAO0C,GAAOrV,EAAEuJ,KAAK8F,MAAMsD,EAAO0C,GAAMxQ,OACnC,CACL8N,EAAO0C,GAAOxQ,IAIpB,OAAO8N,I,gBCvDT,IAAI3S,EAAI,EAAQ,OAChB,EAAQ,OACR,EAAQ,OACR,EAAQ,OACR,EAAQ","file":"8795.13b3cb4f43bf8831d110.js?v=13b3cb4f43bf8831d110","sourcesContent":["function TRUE_FN () { return true; }\n\nL.Canvas.include({\n\n  /**\n   * Do nothing\n   * @param  {L.Path} layer\n   */\n  _resetTransformPath: function(layer) {\n    if (!this._containerCopy) return;\n\n    delete this._containerCopy;\n\n    if (layer._containsPoint_) {\n      layer._containsPoint = layer._containsPoint_;\n      delete layer._containsPoint_;\n\n      this._requestRedraw(layer);\n    }\n  },\n\n\n  /**\n   * Algorithm outline:\n   *\n   * 1. pre-transform - clear the path out of the canvas, copy canvas state\n   * 2. at every frame:\n   *    2.1. save\n   *    2.2. redraw the canvas from saved one\n   *    2.3. transform\n   *    2.4. draw path\n   *    2.5. restore\n   * 3. Repeat\n   *\n   * @param  {L.Path}         layer\n   * @param  {Array.<Number>} matrix\n   */\n  transformPath: function(layer, matrix) {\n    var copy   = this._containerCopy;\n    var ctx    = this._ctx, copyCtx;\n    var m      = L.Browser.retina ? 2 : 1;\n    var bounds = this._bounds;\n    var size   = bounds.getSize();\n    var pos    = bounds.min;\n\n    if (!copy) { // get copy of all rendered layers\n      copy = this._containerCopy = document.createElement('canvas');\n      copyCtx = copy.getContext('2d');\n      // document.body.appendChild(copy);\n\n      copy.width  = m * size.x;\n      copy.height = m * size.y;\n\n      this._removePath(layer);\n      this._redraw();\n\n      copyCtx.translate(m * bounds.min.x, m * bounds.min.y);\n      copyCtx.drawImage(this._container, 0, 0);\n      this._initPath(layer);\n\n      // avoid flickering because of the 'mouseover's\n      layer._containsPoint_ = layer._containsPoint;\n      layer._containsPoint  = TRUE_FN;\n    }\n\n    ctx.save();\n    ctx.clearRect(pos.x, pos.y, size.x * m, size.y * m);\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.restore();\n    ctx.save();\n\n    ctx.drawImage(this._containerCopy, 0, 0, size.x, size.y);\n    ctx.transform.apply(ctx, matrix);\n\n    // now draw one layer only\n    this._drawing = true;\n    layer._updatePath();\n    this._drawing = false;\n\n    ctx.restore();\n  }\n\n});\n","/**\n * @class  L.Matrix\n *\n * @param {Number} a\n * @param {Number} b\n * @param {Number} c\n * @param {Number} d\n * @param {Number} e\n * @param {Number} f\n */\nL.Matrix = function(a, b, c, d, e, f) {\n\n  /**\n   * @type {Array.<Number>}\n   */\n  this._matrix = [a, b, c, d, e, f];\n};\n\n\nL.Matrix.prototype = {\n\n\n  /**\n   * @param  {L.Point} point\n   * @return {L.Point}\n   */\n  transform: function(point) {\n    return this._transform(point.clone());\n  },\n\n\n  /**\n   * Destructive\n   *\n   * [ x ] = [ a  b  tx ] [ x ] = [ a * x + b * y + tx ]\n   * [ y ] = [ c  d  ty ] [ y ] = [ c * x + d * y + ty ]\n   *\n   * @param  {L.Point} point\n   * @return {L.Point}\n   */\n  _transform: function(point) {\n    var matrix = this._matrix;\n    var x = point.x, y = point.y;\n    point.x = matrix[0] * x + matrix[1] * y + matrix[4];\n    point.y = matrix[2] * x + matrix[3] * y + matrix[5];\n    return point;\n  },\n\n\n  /**\n   * @param  {L.Point} point\n   * @return {L.Point}\n   */\n  untransform: function (point) {\n    var matrix = this._matrix;\n    return new L.Point(\n      (point.x / matrix[0] - matrix[4]) / matrix[0],\n      (point.y / matrix[2] - matrix[5]) / matrix[2]\n    );\n  },\n\n\n  /**\n   * @return {L.Matrix}\n   */\n  clone: function() {\n    var matrix = this._matrix;\n    return new L.Matrix(\n      matrix[0], matrix[1], matrix[2],\n      matrix[3], matrix[4], matrix[5]\n    );\n  },\n\n\n  /**\n   * @param {L.Point=|Number=} translate\n   * @return {L.Matrix|L.Point}\n   */\n  translate: function(translate) {\n    if (translate === undefined) {\n      return new L.Point(this._matrix[4], this._matrix[5]);\n    }\n\n    var translateX, translateY;\n    if (typeof translate === 'number') {\n      translateX = translateY = translate;\n    } else {\n      translateX = translate.x;\n      translateY = translate.y;\n    }\n\n    return this._add(1, 0, 0, 1, translateX, translateY);\n  },\n\n\n  /**\n   * @param {L.Point=|Number=} scale\n   * @return {L.Matrix|L.Point}\n   */\n  scale: function(scale, origin) {\n    if (scale === undefined) {\n      return new L.Point(this._matrix[0], this._matrix[3]);\n    }\n\n    var scaleX, scaleY;\n    origin = origin || L.point(0, 0);\n    if (typeof scale === 'number') {\n      scaleX = scaleY = scale;\n    } else {\n      scaleX = scale.x;\n      scaleY = scale.y;\n    }\n\n    return this\n      ._add(scaleX, 0, 0, scaleY, origin.x, origin.y)\n      ._add(1, 0, 0, 1, -origin.x, -origin.y);\n  },\n\n\n  /**\n   * m00  m01  x - m00 * x - m01 * y\n   * m10  m11  y - m10 * x - m11 * y\n   * @param {Number}   angle\n   * @param {L.Point=} origin\n   * @return {L.Matrix}\n   */\n  rotate: function(angle, origin) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n\n    origin = origin || new L.Point(0, 0);\n\n    return this\n      ._add(cos, sin, -sin, cos, origin.x, origin.y)\n      ._add(1, 0, 0, 1, -origin.x, -origin.y);\n  },\n\n\n  /**\n   * Invert rotation\n   * @return {L.Matrix}\n   */\n  flip: function() {\n    this._matrix[1] *= -1;\n    this._matrix[2] *= -1;\n    return this;\n  },\n\n\n  /**\n   * @param {Number|L.Matrix} a\n   * @param {Number} b\n   * @param {Number} c\n   * @param {Number} d\n   * @param {Number} e\n   * @param {Number} f\n   */\n  _add: function(a, b, c, d, e, f) {\n    var result = [[], [], []];\n    var src = this._matrix;\n    var m = [\n      [src[0], src[2], src[4]],\n      [src[1], src[3], src[5]],\n      [     0,      0,     1]\n    ];\n    var other = [\n      [a, c, e],\n      [b, d, f],\n      [0, 0, 1]\n    ], val;\n\n\n    if (a && a instanceof L.Matrix) {\n      src = a._matrix;\n      other = [\n        [src[0], src[2], src[4]],\n        [src[1], src[3], src[5]],\n        [     0,      0,     1]];\n    }\n\n    for (var i = 0; i < 3; i++) {\n      for (var j = 0; j < 3; j++) {\n        val = 0;\n        for (var k = 0; k < 3; k++) {\n          val += m[i][k] * other[k][j];\n        }\n        result[i][j] = val;\n      }\n    }\n\n    this._matrix = [\n      result[0][0], result[1][0], result[0][1],\n      result[1][1], result[0][2], result[1][2]\n    ];\n    return this;\n  }\n\n\n};\n\n\nL.matrix = function(a, b, c, d, e, f) {\n  return new L.Matrix(a, b, c, d, e, f);\n};\n","require('./SVG');\nrequire('./SVG.VML');\nrequire('./Canvas');\n\n/**\n * Leaflet vector features drag functionality\n * @author Alexander Milevski <info@w8r.name>\n * @preserve\n */\n\n/**\n * Matrix transform path for SVG/VML\n * Renderer-independent\n */\nL.Path.include({\n\n\t/**\n\t * Applies matrix transformation to SVG\n\t * @param {Array.<Number>?} matrix\n\t */\n\t_transform: function(matrix) {\n\t\tif (this._renderer) {\n\t\t\tif (matrix) {\n\t\t\t\tthis._renderer.transformPath(this, matrix);\n\t\t\t} else {\n\t\t\t\t// reset transform matrix\n\t\t\t\tthis._renderer._resetTransformPath(this);\n\t\t\t\tthis._update();\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\t/**\n\t * Check if the feature was dragged, that'll supress the click event\n\t * on mouseup. That fixes popups for example\n\t *\n\t * @param  {MouseEvent} e\n\t */\n\t_onMouseClick: function(e) {\n\t\tif ((this.dragging && this.dragging.moved()) ||\n\t\t\t(this._map.dragging && this._map.dragging.moved())) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._fireMouseEvent(e);\n\t}\n\n});\n\n\nvar END = {\n  mousedown:     'mouseup',\n  touchstart:    'touchend',\n  pointerdown:   'touchend',\n  MSPointerDown: 'touchend'\n};\n\nvar MOVE = {\n  mousedown:     'mousemove',\n  touchstart:    'touchmove',\n  pointerdown:   'touchmove',\n  MSPointerDown: 'touchmove'\n};\n\nfunction distance(a, b) {\n  var dx = a.x - b.x, dy = a.y - b.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\n/**\n * Drag handler\n * @class L.Path.Drag\n * @extends {L.Handler}\n */\nL.Handler.PathDrag = L.Handler.extend( /** @lends  L.Path.Drag.prototype */ {\n\n  statics: {\n    DRAGGING_CLS: 'leaflet-path-draggable',\n  },\n\n\n  /**\n   * @param  {L.Path} path\n   * @constructor\n   */\n  initialize: function(path) {\n\n    /**\n     * @type {L.Path}\n     */\n    this._path = path;\n\n    /**\n     * @type {Array.<Number>}\n     */\n    this._matrix = null;\n\n    /**\n     * @type {L.Point}\n     */\n    this._startPoint = null;\n\n    /**\n     * @type {L.Point}\n     */\n    this._dragStartPoint = null;\n\n    /**\n     * @type {Boolean}\n     */\n    this._mapDraggingWasEnabled = false;\n\n  },\n\n  /**\n   * Enable dragging\n   */\n  addHooks: function() {\n    this._path.on('mousedown', this._onDragStart, this);\n\n    this._path.options.className = this._path.options.className ?\n        (this._path.options.className + ' ' + L.Handler.PathDrag.DRAGGING_CLS) :\n         L.Handler.PathDrag.DRAGGING_CLS;\n\n    if (this._path._path) {\n      L.DomUtil.addClass(this._path._path, L.Handler.PathDrag.DRAGGING_CLS);\n    }\n  },\n\n  /**\n   * Disable dragging\n   */\n  removeHooks: function() {\n    this._path.off('mousedown', this._onDragStart, this);\n\n    this._path.options.className = this._path.options.className\n      .replace(new RegExp('\\\\s+' + L.Handler.PathDrag.DRAGGING_CLS), '');\n    if (this._path._path) {\n      L.DomUtil.removeClass(this._path._path, L.Handler.PathDrag.DRAGGING_CLS);\n    }\n  },\n\n  /**\n   * @return {Boolean}\n   */\n  moved: function() {\n    return this._path._dragMoved;\n  },\n\n  /**\n   * Start drag\n   * @param  {L.MouseEvent} evt\n   */\n  _onDragStart: function(evt) {\n    var eventType = evt.originalEvent._simulated ? 'touchstart' : evt.originalEvent.type;\n\n    this._mapDraggingWasEnabled = false;\n    this._startPoint = evt.containerPoint.clone();\n    this._dragStartPoint = evt.containerPoint.clone();\n    this._matrix = [1, 0, 0, 1, 0, 0];\n    L.DomEvent.stop(evt.originalEvent);\n\n    L.DomUtil.addClass(this._path._renderer._container, 'leaflet-interactive');\n    L.DomEvent\n      .on(document, MOVE[eventType], this._onDrag,    this)\n      .on(document, END[eventType],  this._onDragEnd, this);\n\n    if (this._path._map.dragging.enabled()) {\n      // I guess it's required because mousdown gets simulated with a delay\n      //this._path._map.dragging._draggable._onUp(evt);\n\n      this._path._map.dragging.disable();\n      this._mapDraggingWasEnabled = true;\n    }\n    this._path._dragMoved = false;\n\n    if (this._path._popup) { // that might be a case on touch devices as well\n      this._path._popup._close();\n    }\n\n    this._replaceCoordGetters(evt);\n  },\n\n  /**\n   * Dragging\n   * @param  {L.MouseEvent} evt\n   */\n  _onDrag: function(evt) {\n    L.DomEvent.stop(evt);\n\n    var first = (evt.touches && evt.touches.length >= 1 ? evt.touches[0] : evt);\n    var containerPoint = this._path._map.mouseEventToContainerPoint(first);\n\n    // skip taps\n    if (evt.type === 'touchmove' && !this._path._dragMoved) {\n      var totalMouseDragDistance = this._dragStartPoint.distanceTo(containerPoint);\n      if (totalMouseDragDistance <= this._path._map.options.tapTolerance) {\n        return;\n      }\n    }\n\n    var x = containerPoint.x;\n    var y = containerPoint.y;\n\n    var dx = x - this._startPoint.x;\n    var dy = y - this._startPoint.y;\n\n    // Send events only if point was moved\n    if (dx || dy) {\n      if (!this._path._dragMoved) {\n        this._path._dragMoved = true;\n        this._path.fire('dragstart', evt);\n        // we don't want that to happen on click\n        this._path.bringToFront();\n      }\n\n      this._matrix[4] += dx;\n      this._matrix[5] += dy;\n\n      this._startPoint.x = x;\n      this._startPoint.y = y;\n\n      this._path.fire('predrag', evt);\n      this._path._transform(this._matrix);\n      this._path.fire('drag', evt);\n    }\n  },\n\n  /**\n   * Dragging stopped, apply\n   * @param  {L.MouseEvent} evt\n   */\n  _onDragEnd: function(evt) {\n    var containerPoint = this._path._map.mouseEventToContainerPoint(evt);\n    var moved = this.moved();\n\n    // apply matrix\n    if (moved) {\n      this._transformPoints(this._matrix);\n      this._path._updatePath();\n      this._path._project();\n      this._path._transform(null);\n\n      L.DomEvent.stop(evt);\n    }\n\n\n    L.DomEvent.off(document, 'mousemove touchmove', this._onDrag,    this);\n    L.DomEvent.off(document, 'mouseup touchend',    this._onDragEnd, this);\n\n    this._restoreCoordGetters();\n\n    // consistency\n    if (moved) {\n      this._path.fire('dragend', {\n        distance: distance(this._dragStartPoint, containerPoint)\n      });\n\n      // hack for skipping the click in canvas-rendered layers\n      var contains = this._path._containsPoint;\n      this._path._containsPoint = L.Util.falseFn;\n      L.Util.requestAnimFrame(function() {\n        L.DomEvent.skipped({ type: 'click' });\n        this._path._containsPoint = contains;\n      }, this);\n    }\n\n    this._matrix          = null;\n    this._startPoint      = null;\n    this._dragStartPoint  = null;\n    this._path._dragMoved = false;\n\n    if (this._mapDraggingWasEnabled) {\n      if (moved) L.DomEvent.fakeStop({ type: 'click' });\n      this._path._map.dragging.enable();\n    }\n  },\n\n\n  /**\n   * Applies transformation, does it in one sweep for performance,\n   * so don't be surprised about the code repetition.\n   *\n   * [ x ]   [ a  b  tx ] [ x ]   [ a * x + b * y + tx ]\n   * [ y ] = [ c  d  ty ] [ y ] = [ c * x + d * y + ty ]\n   *\n   * @param {Array.<Number>} matrix\n   */\n  _transformPoints: function(matrix, dest) {\n    var path = this._path;\n    var i, len, latlng;\n\n    var px = L.point(matrix[4], matrix[5]);\n\n    var crs = path._map.options.crs;\n    var transformation = crs.transformation;\n    var scale = crs.scale(path._map.getZoom());\n    var projection = crs.projection;\n\n    var diff = transformation.untransform(px, scale)\n      .subtract(transformation.untransform(L.point(0, 0), scale));\n    var applyTransform = !dest;\n\n    path._bounds = new L.LatLngBounds();\n\n    // console.time('transform');\n    // all shifts are in-place\n    if (path._point) { // L.Circle\n      dest = projection.unproject(\n        projection.project(path._latlng)._add(diff));\n      if (applyTransform) {\n        path._latlng = dest;\n        path._point._add(px);\n      }\n    } else if (path._rings || path._parts) { // everything else\n      var rings   = path._rings || path._parts;\n      var latlngs = path._latlngs;\n      dest = dest || latlngs;\n      if (!L.Util.isArray(latlngs[0])) { // polyline\n        latlngs = [latlngs];\n        dest    = [dest];\n      }\n      for (i = 0, len = latlngs.length; i < len; i++) {\n        dest[i] = dest[i] || [];\n        for (var j = 0, jj = latlngs[i].length; j < jj; j++) {\n          latlng     = latlngs[i][j];\n          dest[i][j] = projection\n            .unproject(projection.project(latlng)._add(diff));\n          if (applyTransform) {\n            path._bounds.extend(latlngs[i][j]);\n            if (rings[i][j]) {\n                rings[i][j]._add(px);\n            }\n          }\n        }\n      }\n    }\n    return dest;\n    // console.timeEnd('transform');\n  },\n\n\n\n  /**\n   * If you want to read the latlngs during the drag - your right,\n   * but they have to be transformed\n   */\n  _replaceCoordGetters: function() {\n    if (this._path.getLatLng) { // Circle, CircleMarker\n      this._path.getLatLng_ = this._path.getLatLng;\n      this._path.getLatLng = L.Util.bind(function() {\n        return this.dragging._transformPoints(this.dragging._matrix, {});\n      }, this._path);\n    } else if (this._path.getLatLngs) {\n      this._path.getLatLngs_ = this._path.getLatLngs;\n      this._path.getLatLngs = L.Util.bind(function() {\n        return this.dragging._transformPoints(this.dragging._matrix, []);\n      }, this._path);\n    }\n  },\n\n\n  /**\n   * Put back the getters\n   */\n  _restoreCoordGetters: function() {\n    if (this._path.getLatLng_) {\n      this._path.getLatLng = this._path.getLatLng_;\n      delete this._path.getLatLng_;\n    } else if (this._path.getLatLngs_) {\n      this._path.getLatLngs = this._path.getLatLngs_;\n      delete this._path.getLatLngs_;\n    }\n  }\n\n});\n\n\n/**\n * @param  {L.Path} layer\n * @return {L.Path}\n */\nL.Handler.PathDrag.makeDraggable = function(layer) {\n  layer.dragging = new L.Handler.PathDrag(layer);\n  return layer;\n};\n\n\n/**\n * Also expose as a method\n * @return {L.Path}\n */\nL.Path.prototype.makeDraggable = function() {\n  return L.Handler.PathDrag.makeDraggable(this);\n};\n\n\nL.Path.addInitHook(function() {\n  if (this.options.draggable) {\n    // ensure interactive\n    this.options.interactive = true;\n\n    if (this.dragging) {\n      this.dragging.enable();\n    } else {\n      L.Handler.PathDrag.makeDraggable(this);\n      this.dragging.enable();\n    }\n  } else if (this.dragging) {\n    this.dragging.disable();\n  }\n});\n\nmodule.exports = L.Path.Drag;\n","\n\n/**\n * Marker handler\n * @extends {L.CircleMarker}\n */\nL.PathTransform.Handle = L.CircleMarker.extend({\n  options: {\n    className: 'leaflet-path-transform-handler'\n  },\n\n  onAdd: function (map) {\n    L.CircleMarker.prototype.onAdd.call(this, map);\n    if (this._path && this.options.setCursor) { // SVG/VML\n      this._path.style.cursor = L.PathTransform.Handle.CursorsByType[\n        this.options.index\n      ];\n    }\n  }\n});\n\n\n/**\n * @const\n * @type {Array}\n */\nL.PathTransform.Handle.CursorsByType = [\n  'nesw-resize', 'nwse-resize', 'nesw-resize', 'nwse-resize'\n];\n\n\n/**\n * @extends {L.Handler.PathTransform.Handle}\n */\nL.PathTransform.RotateHandle = L.PathTransform.Handle.extend({\n  options: {\n    className: 'leaflet-path-transform-handler transform-handler--rotate'\n  },\n\n  onAdd: function (map) {\n    L.CircleMarker.prototype.onAdd.call(this, map);\n    if (this._path && this.options.setCursor) { // SVG/VML\n      this._path.style.cursor = 'all-scroll';\n    }\n  }\n});\n\nL.Handler.PathTransform = L.Handler.extend({\n\n  options: {\n    rotation: true,\n    scaling:  true,\n    uniformScaling: true,\n    maxZoom:  22,\n\n    // edge handlers\n    handlerOptions: {\n      radius:      5,\n      fillColor:   '#ffffff',\n      color:       '#202020',\n      fillOpacity: 1,\n      weight:      2,\n      opacity:     0.7,\n      setCursor:   true\n    },\n\n    // rectangle\n    boundsOptions: {\n      weight:    1,\n      opacity:   1,\n      dashArray: [3, 3],\n      fill:      false,\n      noClip:    true\n    },\n\n    // rotation handler\n    rotateHandleOptions: {\n      weight:    1,\n      opacity:   1,\n      setCursor: true\n    },\n    // rotation handle length\n    handleLength: 20,\n\n    // maybe I'll add skewing in the future\n    edgesCount:   4,\n\n    handleClass:       L.PathTransform.Handle,\n    rotateHandleClass: L.PathTransform.RotateHandle\n  },\n\n\n  /**\n   * @class L.Handler.PathTransform\n   * @constructor\n   * @param  {L.Path} path\n   */\n  initialize: function(path) {\n    // references\n    this._path = path;\n    this._map  = null;\n\n    // handlers\n    this._activeMarker   = null;\n    this._originMarker   = null;\n    this._rotationMarker = null;\n\n    // origins & temporary state\n    this._rotationOrigin   = null;\n    this._scaleOrigin      = null;\n    this._angle            = 0;\n    this._scale            = L.point(1, 1);\n    this._initialDist      = 0;\n    this._initialDistX     = 0;\n    this._initialDistY     = 0;\n    this._rotationStart    = null;\n    this._rotationOriginPt = null;\n\n    // preview and transform matrix\n    this._matrix          = new L.Matrix(1, 0, 0, 1, 0, 0);\n    this._projectedMatrix = new L.Matrix(1, 0, 0, 1, 0, 0);\n\n    // ui elements\n    this._handlersGroup  = null;\n    this._rect           = null;\n    this._handlers       = [];\n    this._handleLine     = null;\n  },\n\n\n  /**\n   * If the polygon is not rendered, you can transform it yourself\n   * in the coordinates, and do it properly.\n   * @param {Object=} options\n   */\n  enable: function(options) {\n    if (this._path._map) {\n      this._map = this._path._map;\n      if (options) {\n        this.setOptions(options);\n      }\n      L.Handler.prototype.enable.call(this);\n    }\n  },\n\n\n  /**\n   * Init interactions and handlers\n   */\n  addHooks: function() {\n    this._createHandlers();\n    this._path\n      .on('dragstart', this._onDragStart, this)\n      .on('dragend',   this._onDragEnd,   this);\n  },\n\n\n  /**\n   * Remove handlers\n   */\n  removeHooks: function() {\n    this._hideHandlers();\n    this._path\n      .off('dragstart', this._onDragStart, this)\n      .off('dragend',   this._onDragEnd,   this);\n    this._handlersGroup = null;\n    this._rect = null;\n    this._handlers = [];\n  },\n\n\n  /**\n   * Change editing options\n   * @param {Object} options\n   */\n  setOptions: function(options) {\n    var enabled = this._enabled;\n    if (enabled) {\n      this.disable();\n    }\n\n    this.options = L.PathTransform.merge({},\n      L.Handler.PathTransform.prototype.options,\n      options);\n\n    if (enabled) {\n      this.enable();\n    }\n\n    return this;\n  },\n\n\n  /**\n   * @param  {Number}   angle\n   * @param  {L.LatLng} origin\n   * @return {L.Handler.PathTransform}\n   */\n  rotate: function(angle, origin) {\n    return this.transform(angle, null, origin);\n  },\n\n\n  /**\n   * @param  {L.Point|Number} scale\n   * @param  {L.LatLng}       origin\n   * @return {L.Handler.PathTransform}\n   */\n  scale: function(scale, origin) {\n    if (typeof scale === 'number') {\n      scale = L.point(scale, scale);\n    }\n    return this.transform(0, scale, null, origin);\n  },\n\n\n  /**\n   * @param  {Number}    angle\n   * @param  {L.Point}   scale\n   * @param  {L.LatLng=} rotationOrigin\n   * @param  {L.LatLng=} scaleOrigin\n   * @return {L.Handler.PathTransform}\n   */\n  transform: function(angle, scale, rotationOrigin, scaleOrigin) {\n    var center     = this._path.getCenter();\n    rotationOrigin = rotationOrigin || center;\n    scaleOrigin    = scaleOrigin    || center;\n    this._map = this._path._map;\n    this._transformPoints(this._path, angle, scale, rotationOrigin, scaleOrigin);\n    this._transformPoints(this._rect, angle, scale, rotationOrigin, scaleOrigin);\n    this._transformPoints(this._handleLine, angle, scale, rotationOrigin, scaleOrigin);\n    this._updateHandlers();\n    return this;\n  },\n\n\n  /**\n   * Update the polygon and handlers preview, no reprojection\n   */\n  _update: function() {\n    var matrix = this._matrix;\n\n    // update handlers\n    for (var i = 0, len = this._handlers.length; i < len; i++) {\n      var handler = this._handlers[i];\n      if (handler !== this._originMarker) {\n        handler._point = matrix.transform(handler._initialPoint);\n        handler._updatePath();\n      }\n    }\n\n    matrix = matrix.clone().flip();\n\n    this._applyTransform(matrix);\n    this._path.fire('transform', { layer: this._path });\n  },\n\n\n  /**\n   * @param  {L.Matrix} matrix\n   */\n  _applyTransform: function(matrix) {\n    this._path._transform(matrix._matrix);\n    this._rect._transform(matrix._matrix);\n\n    if (this.options.rotation) {\n      this._handleLine._transform(matrix._matrix);\n    }\n  },\n\n\n  /**\n   * Apply final transformation\n   */\n  _apply: function() {\n    //console.group('apply transform');\n    var map = this._map;\n    var matrix = this._matrix.clone();\n    var angle = this._angle;\n    var scale = this._scale.clone();\n\n    this._transformGeometries();\n\n    // update handlers\n    for (var i = 0, len = this._handlers.length; i < len; i++) {\n      var handler = this._handlers[i];\n      handler._latlng = map.layerPointToLatLng(handler._point);\n      delete handler._initialPoint;\n      handler.redraw();\n    }\n\n    this._matrix = L.matrix(1, 0, 0, 1, 0, 0);\n    this._scale  = L.point(1, 1);\n    this._angle  = 0;\n\n    this._updateHandlers();\n\n    map.dragging.enable();\n    this._path.fire('transformed', {\n      matrix: matrix,\n      scale: scale,\n      rotation: angle,\n      // angle: angle * (180 / Math.PI),\n      layer: this._path\n    });\n    // console.groupEnd('apply transform');\n  },\n\n\n  /**\n   * Use this method to completely reset handlers, if you have changed the\n   * geometry of transformed layer\n   */\n  reset: function() {\n    this._rectShape = null;\n    if (this._enabled) {\n      if (this._rect) {\n        this._handlersGroup.removeLayer(this._rect);\n      }\n      this._rect = this._getBoundingPolygon().addTo(this._handlersGroup);\n      this._updateHandlers();\n    }\n  },\n\n\n  /**\n   * Recalculate rotation handlers position\n   */\n  _updateHandlers: function() {\n    var handlersGroup = this._handlersGroup;\n\n    this._rectShape = this._rect.toGeoJSON();\n\n    if (this._handleLine) {\n      this._handlersGroup.removeLayer(this._handleLine);\n    }\n\n    if (this._rotationMarker) {\n      this._handlersGroup.removeLayer(this._rotationMarker);\n    }\n\n    this._handleLine = this._rotationMarker = null;\n\n    for (var i = this._handlers.length - 1; i >= 0; i--) {\n      handlersGroup.removeLayer(this._handlers[i]);\n    }\n\n    this._createHandlers();\n  },\n\n\n  /**\n   * Transform geometries separately\n   */\n  _transformGeometries: function() {\n    this._path._transform(null);\n    this._rect._transform(null);\n\n    this._transformPoints(this._path);\n    this._transformPoints(this._rect);\n\n    if (this.options.rotation) {\n      this._handleLine._transform(null);\n      this._transformPoints(this._handleLine, this._angle, null, this._origin);\n    }\n  },\n\n\n  /**\n   * @param {Number} angle\n   * @param {Number} scale\n   * @param {L.LatLng=} rotationOrigin\n   * @param {L.LatLng=} scaleOrigin\n   */\n  _getProjectedMatrix: function(angle, scale, rotationOrigin, scaleOrigin) {\n    var map    = this._map;\n    var zoom   = map.getMaxZoom() || this.options.maxZoom;\n    var matrix = L.matrix(1, 0, 0, 1, 0, 0);\n    var origin;\n\n    angle = angle || this._angle || 0;\n    scale = scale || this._scale || L.point(1, 1);\n\n    if (!(scale.x === 1 && scale.y === 1)) {\n      scaleOrigin = scaleOrigin || this._scaleOrigin;\n      origin = map.project(scaleOrigin, zoom);\n      matrix = matrix\n        ._add(L.matrix(1, 0, 0, 1, origin.x, origin.y))\n        ._add(L.matrix(scale.x, 0, 0, scale.y, 0, 0))\n        ._add(L.matrix(1, 0, 0, 1, -origin.x, -origin.y));\n    }\n\n    if (angle) {\n      rotationOrigin = rotationOrigin || this._rotationOrigin;\n      origin = map.project(rotationOrigin, zoom);\n      matrix = matrix.rotate(angle, origin).flip();\n    }\n\n    return matrix;\n  },\n\n\n  /**\n   * @param  {L.LatLng} latlng\n   * @param  {L.Matrix} matrix\n   * @param  {L.Map}    map\n   * @param  {Number}   zoom\n   * @return {L.LatLng}\n   */\n  _transformPoint: function(latlng, matrix, map, zoom) {\n    return map.unproject(matrix.transform(\n      map.project(latlng, zoom)), zoom);\n  },\n\n\n  /**\n   * Applies transformation, does it in one sweep for performance,\n   * so don't be surprised about the code repetition.\n   *\n   * @param {L.Path}    path\n   * @param {Number=}   angle\n   * @param {L.Point=}  scale\n   * @param {L.LatLng=} rotationOrigin\n   * @param {L.LatLng=} scaleOrigin\n   */\n  _transformPoints: function(path, angle, scale, rotationOrigin, scaleOrigin) {\n    var map = path._map;\n    var zoom = map.getMaxZoom() || this.options.maxZoom;\n    var i, len;\n\n    var projectedMatrix = this._projectedMatrix =\n      this._getProjectedMatrix(angle, scale, rotationOrigin, scaleOrigin);\n    // console.time('transform');\n\n    // all shifts are in-place\n    if (path._point) { // L.Circle\n      path._latlng = this._transformPoint(\n        path._latlng, projectedMatrix, map, zoom);\n    } else if (path._rings || path._parts) { // everything else\n      var latlngs = path._latlngs;\n      path._bounds = new L.LatLngBounds();\n\n      if (!L.Util.isArray(latlngs[0])) { // polyline\n        latlngs = [latlngs];\n      }\n      for (i = 0, len = latlngs.length; i < len; i++) {\n        for (var j = 0, jj = latlngs[i].length; j < jj; j++) {\n          latlngs[i][j] = this._transformPoint(\n            latlngs[i][j], projectedMatrix, map, zoom);\n          path._bounds.extend(latlngs[i][j]);\n        }\n      }\n    }\n\n    path._reset();\n    //console.timeEnd('transform');\n  },\n\n\n  /**\n   * Creates markers and handles\n   */\n  _createHandlers: function() {\n    var map = this._map;\n    this._handlersGroup = this._handlersGroup ||\n                          new L.LayerGroup().addTo(map);\n    this._rect = this._rect ||\n                 this._getBoundingPolygon().addTo(this._handlersGroup);\n\n    if (this.options.scaling) {\n      this._handlers = [];\n      for (var i = 0; i < this.options.edgesCount; i++) {\n        // TODO: add stretching\n        this._handlers.push(\n          this._createHandler(this._rect._latlngs[0][i], i * 2, i)\n          .addTo(this._handlersGroup));\n      }\n    }\n\n    // add bounds\n    if (this.options.rotation) {\n      //add rotation handler\n      this._createRotationHandlers();\n    }\n  },\n\n\n  /**\n   * Rotation marker and small connectin handle\n   */\n  _createRotationHandlers: function() {\n    var map     = this._map;\n    var latlngs = this._rect._latlngs[0];\n\n    var bottom   = new L.LatLng(\n      (latlngs[0].lat + latlngs[3].lat) / 2,\n      (latlngs[0].lng + latlngs[3].lng) / 2);\n    // hehe, top is a reserved word\n    var topPoint = new L.LatLng(\n      (latlngs[1].lat + latlngs[2].lat) / 2,\n      (latlngs[1].lng + latlngs[2].lng) / 2);\n\n    var handlerPosition = map.layerPointToLatLng(\n      L.PathTransform.pointOnLine(\n        map.latLngToLayerPoint(bottom),\n        map.latLngToLayerPoint(topPoint),\n        this.options.handleLength)\n    );\n\n    this._handleLine = new L.Polyline([topPoint, handlerPosition],\n      this.options.rotateHandleOptions).addTo(this._handlersGroup);\n    var RotateHandleClass = this.options.rotateHandleClass;\n    this._rotationMarker = new RotateHandleClass(handlerPosition,\n      this.options.handlerOptions)\n      .addTo(this._handlersGroup)\n      .on('mousedown', this._onRotateStart, this);\n\n    this._rotationOrigin = new L.LatLng(\n      (topPoint.lat + bottom.lat) / 2,\n      (topPoint.lng + bottom.lng) / 2\n    );\n\n    this._handlers.push(this._rotationMarker);\n  },\n\n\n  /**\n   * @return {L.LatLng}\n   */\n  _getRotationOrigin: function() {\n    var latlngs = this._rect._latlngs[0];\n    var lb = latlngs[0];\n    var rt = latlngs[2];\n\n    return new L.LatLng(\n      (lb.lat + rt.lat) / 2,\n      (lb.lng + rt.lng) / 2\n    );\n  },\n\n\n  /**\n   * Secure the rotation origin\n   * @param  {Event} evt\n   */\n  _onRotateStart: function(evt) {\n    var map = this._map;\n\n    map.dragging.disable();\n\n    this._originMarker     = null;\n    this._rotationOriginPt = map.latLngToLayerPoint(this._getRotationOrigin());\n    this._rotationStart    = evt.layerPoint;\n    this._initialMatrix    = this._matrix.clone();\n\n    this._angle = 0;\n    this._path._map\n      .on('mousemove', this._onRotate,     this)\n      .on('mouseup',   this._onRotateEnd, this);\n\n    this._cachePoints();\n    this._path\n      .fire('transformstart',   { layer: this._path })\n      .fire('rotatestart', { layer: this._path, rotation: 0 });\n  },\n\n\n  /**\n   * @param  {Event} evt\n   */\n  _onRotate: function(evt) {\n    var pos = evt.layerPoint;\n    var previous = this._rotationStart;\n    var origin   = this._rotationOriginPt;\n\n    // rotation step angle\n    this._angle = Math.atan2(pos.y - origin.y, pos.x - origin.x) -\n                  Math.atan2(previous.y - origin.y, previous.x - origin.x);\n\n    this._matrix = this._initialMatrix\n      .clone()\n      .rotate(this._angle, origin)\n      .flip();\n\n    this._update();\n    this._path.fire('rotate', { layer: this._path, rotation: this._angle });\n  },\n\n\n  /**\n   * @param  {Event} evt\n   */\n  _onRotateEnd: function(evt) {\n    this._path._map\n      .off('mousemove', this._onRotate, this)\n      .off('mouseup',   this._onRotateEnd, this);\n\n    var angle = this._angle;\n    this._apply();\n    this._path.fire('rotateend', { layer: this._path, rotation: angle });\n  },\n\n\n  /**\n   * @param  {Event} evt\n   */\n  _onScaleStart: function(evt) {\n    var marker = evt.target;\n    var map = this._map;\n\n    map.dragging.disable();\n\n    this._activeMarker = marker;\n\n    this._originMarker = this._handlers[(marker.options.index + 2) % 4];\n    this._scaleOrigin  = this._originMarker.getLatLng();\n\n    this._initialMatrix = this._matrix.clone();\n    this._cachePoints();\n\n    this._map\n      .on('mousemove', this._onScale,    this)\n      .on('mouseup',   this._onScaleEnd, this);\n    this._initialDist  = this._originMarker._point.distanceTo(this._activeMarker._point);\n    this._initialDistX = this._originMarker._point.x - this._activeMarker._point.x;\n    this._initialDistY = this._originMarker._point.y - this._activeMarker._point.y;\n\n    this._path\n      .fire('transformstart', { layer: this._path })\n      .fire('scalestart', { layer: this._path, scale: L.point(1, 1) });\n\n    if (this._handleLine) {\n      this._map.removeLayer(this._handleLine);\n    }\n    if (this._rotationMarker) {\n      this._map.removeLayer(this._rotationMarker);\n    }\n\n    //this._handleLine = this._rotationMarker = null;\n  },\n\n\n  /**\n   * @param  {Event} evt\n   */\n  _onScale: function(evt) {\n    var originPoint = this._originMarker._point;\n    var ratioX, ratioY;\n    if (this.options.uniformScaling) {\n      ratioX = originPoint.distanceTo(evt.layerPoint) / this._initialDist;\n      ratioY = ratioX;\n    } else {\n      ratioX = (originPoint.x - evt.layerPoint.x) / this._initialDistX;\n      ratioY = (originPoint.y - evt.layerPoint.y) / this._initialDistY;\n    }\n\n    this._scale = new L.Point(ratioX, ratioY);\n\n    // update matrix\n    this._matrix = this._initialMatrix\n      .clone()\n      .scale(this._scale, originPoint);\n\n    this._update();\n    this._path.fire('scale', {\n      layer: this._path, scale: this._scale.clone() });\n  },\n\n\n  /**\n   * Scaling complete\n   * @param  {Event} evt\n   */\n  _onScaleEnd: function(evt) {\n    this._map\n      .off('mousemove', this._onScale,    this)\n      .off('mouseup',   this._onScaleEnd, this);\n\n    if (this._handleLine) {\n      this._map.addLayer(this._handleLine);\n    }\n    if (this._rotationMarker) {\n      this._map.addLayer(this._rotationMarker);\n    }\n\n    this._apply();\n    this._path.fire('scaleend', {\n      layer: this._path, scale: this._scale.clone() });\n  },\n\n\n  /**\n   * Cache current handlers positions\n   */\n  _cachePoints: function() {\n    this._handlersGroup.eachLayer(function(layer) {\n      layer.bringToFront();\n    });\n    for (var i = 0, len = this._handlers.length; i < len; i++) {\n      var handler = this._handlers[i];\n      handler._initialPoint = handler._point.clone();\n    }\n  },\n\n\n  /**\n   * Bounding polygon\n   * @return {L.Polygon}\n   */\n  _getBoundingPolygon: function() {\n    if (this._rectShape) {\n      return L.GeoJSON.geometryToLayer(\n        this._rectShape, this.options.boundsOptions);\n    } else {\n      return new L.Rectangle(\n        this._path.getBounds(), this.options.boundsOptions);\n    }\n  },\n\n\n  /**\n   * Create corner marker\n   * @param  {L.LatLng} latlng\n   * @param  {Number}   type one of L.Handler.PathTransform.HandlerTypes\n   * @param  {Number}   index\n   * @return {L.Handler.PathTransform.Handle}\n   */\n  _createHandler: function(latlng, type, index) {\n    var HandleClass = this.options.handleClass;\n    var marker = new HandleClass(latlng,\n      L.Util.extend({}, this.options.handlerOptions, {\n        className: 'leaflet-drag-transform-marker drag-marker--' +\n                   index + ' drag-marker--' + type,\n        index:     index,\n        type:      type\n      })\n    );\n\n    marker.on('mousedown', this._onScaleStart, this);\n    return marker;\n  },\n\n\n  /**\n   * Hide(not remove) the handlers layer\n   */\n  _hideHandlers: function() {\n    this._map.removeLayer(this._handlersGroup);\n  },\n\n\n  /**\n   * Hide handlers and rectangle\n   */\n  _onDragStart: function() {\n    this._hideHandlers();\n  },\n\n\n  /**\n   * Drag rectangle, re-create handlers\n   */\n  _onDragEnd: function(evt) {\n    var rect = this._rect;\n    var matrix = (evt.layer ? evt.layer : this._path).dragging._matrix.slice();\n\n    if (!rect.dragging) {\n      rect.dragging = new L.Handler.PathDrag(rect);\n    }\n    rect.dragging.enable();\n    this._map.addLayer(rect);\n    rect.dragging._transformPoints(matrix);\n    rect._updatePath();\n    rect._project();\n    rect.dragging.disable();\n\n    this._map.addLayer(this._handlersGroup);\n    this._updateHandlers();\n\n    this._path.fire('transformed', {\n      scale: L.point(1, 1),\n      rotation: 0,\n      matrix: L.matrix.apply(undefined, matrix),\n      translate: L.point(matrix[4], matrix[5]),\n      layer: this._path\n    });\n  }\n});\n\n\nL.Path.addInitHook(function() {\n  if (this.options.transform) {\n    this.transform = new L.Handler.PathTransform(this, this.options.transform);\n  }\n});\n","L.SVG.include(!L.Browser.vml ? {} : {\n\n\t/**\n\t * Reset transform matrix\n\t */\n\t_resetTransformPath: function(layer) {\n\t\tif (layer._skew) {\n\t\t\t// super important! workaround for a 'jumping' glitch:\n\t\t\t// disable transform before removing it\n\t\t\tlayer._skew.on = false;\n\t\t\tlayer._path.removeChild(layer._skew);\n\t\t\tlayer._skew = null;\n\t\t}\n\t},\n\n\t/**\n\t * Applies matrix transformation to VML\n\t * @param {L.Path}         layer\n\t * @param {Array.<Number>} matrix\n\t */\n\ttransformPath: function(layer, matrix) {\n\t\tvar skew = layer._skew;\n\n\t\tif (!skew) {\n\t\t\tskew = L.SVG.create('skew');\n\t\t\tlayer._path.appendChild(skew);\n\t\t\tskew.style.behavior = 'url(#default#VML)';\n\t\t\tlayer._skew = skew;\n\t\t}\n\n\t\t// handle skew/translate separately, cause it's broken\n\t\tvar mt = matrix[0].toFixed(8) + ' ' + matrix[1].toFixed(8) + ' ' +\n\t\t\tmatrix[2].toFixed(8) + ' ' + matrix[3].toFixed(8) + ' 0 0';\n\t\tvar offset = Math.floor(matrix[4]).toFixed() + ', ' +\n\t\t\tMath.floor(matrix[5]).toFixed() + '';\n\n\t\tvar s = this._path.style;\n\t\tvar l = parseFloat(s.left);\n\t\tvar t = parseFloat(s.top);\n\t\tvar w = parseFloat(s.width);\n\t\tvar h = parseFloat(s.height);\n\n\t\tif (isNaN(l))       l = 0;\n\t\tif (isNaN(t))       t = 0;\n\t\tif (isNaN(w) || !w) w = 1;\n\t\tif (isNaN(h) || !h) h = 1;\n\n\t\tvar origin = (-l / w - 0.5).toFixed(8) + ' ' + (-t / h - 0.5).toFixed(8);\n\n\t\tskew.on = 'f';\n\t\tskew.matrix = mt;\n\t\tskew.origin = origin;\n\t\tskew.offset = offset;\n\t\tskew.on = true;\n\t}\n\n});\n","L.SVG.include({\n\n\t/**\n\t * Reset transform matrix\n\t */\n\t_resetTransformPath: function(layer) {\n\t\tlayer._path.setAttributeNS(null, 'transform', '');\n\t},\n\n\t/**\n\t * Applies matrix transformation to SVG\n\t * @param {L.Path}         layer\n\t * @param {Array.<Number>} matrix\n\t */\n\ttransformPath: function(layer, matrix) {\n\t\tlayer._path.setAttributeNS(null, 'transform',\n\t\t\t'matrix(' + matrix.join(' ') + ')');\n\t}\n\n});\n","/**\n * @namespace\n * @type {Object}\n */\nL.PathTransform = {};\n\n/**\n * Point on the line segment or its extention\n *\n * @param  {L.Point} start\n * @param  {L.Point} final\n * @param  {Number}  distPx\n * @return {L.Point}\n */\nL.PathTransform.pointOnLine = function(start, final, distPx) {\n  var ratio = 1 + distPx / start.distanceTo(final);\n  return new L.Point(\n    start.x + (final.x - start.x) * ratio,\n    start.y + (final.y - start.y) * ratio\n  );\n};\n\n\n/**\n * Deep merge objects.\n */\nL.PathTransform.merge = function() {\n  var i = 1;\n  var key, val;\n  var obj = arguments[i];\n\n  function isObject(object) {\n    return Object.prototype.toString.call(object) === '[object Object]';\n  }\n\n  // make sure we don't modify source element and it's properties\n  // objects are passed by reference\n  var target = arguments[0];\n\n  while (obj) {\n    obj = arguments[i++];\n    for (key in obj) {\n      if (!obj.hasOwnProperty(key)) {\n        continue;\n      }\n\n      val = obj[key];\n\n      if (isObject(val) && isObject(target[key])){\n        target[key] = L.Util.merge(target[key], val);\n      } else {\n        target[key] = val;\n      }\n    }\n  }\n  return target;\n};\n","var L = require('leaflet');\nrequire('./Path.Drag');\nrequire('./Util');\nrequire('./Matrix');\nrequire('./Path.Transform');\n"],"sourceRoot":""}